/* Pathfollower.c generated by valac 0.20.1, the Vala compiler
 * generated from Pathfollower.gs, do not modify */

/*
 *  libsoy - soy.controllers.Pathfollower
 *  Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013 Copyleft Games Group
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program; if not, see http://www.gnu.org/licenses
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <soy-1/ode.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <GLES/gl.h>
#include <GLES/glext.h>


#define SOY_CONTROLLERS_TYPE_CONTROLLER (soy_controllers_controller_get_type ())
#define SOY_CONTROLLERS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_CONTROLLERS_TYPE_CONTROLLER, soycontrollersController))
#define SOY_CONTROLLERS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_CONTROLLERS_TYPE_CONTROLLER, soycontrollersControllerClass))
#define SOY_CONTROLLERS_IS_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_CONTROLLERS_TYPE_CONTROLLER))
#define SOY_CONTROLLERS_IS_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_CONTROLLERS_TYPE_CONTROLLER))
#define SOY_CONTROLLERS_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_CONTROLLERS_TYPE_CONTROLLER, soycontrollersControllerClass))

typedef struct _soycontrollersController soycontrollersController;
typedef struct _soycontrollersControllerClass soycontrollersControllerClass;
typedef struct _soycontrollersControllerPrivate soycontrollersControllerPrivate;

#define SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER (soy_controllers_virtual_controller_get_type ())
#define SOY_CONTROLLERS_VIRTUAL_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, soycontrollersVirtualController))
#define SOY_CONTROLLERS_VIRTUAL_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, soycontrollersVirtualControllerClass))
#define SOY_CONTROLLERS_IS_VIRTUAL_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER))
#define SOY_CONTROLLERS_IS_VIRTUAL_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER))
#define SOY_CONTROLLERS_VIRTUAL_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, soycontrollersVirtualControllerClass))

typedef struct _soycontrollersVirtualController soycontrollersVirtualController;
typedef struct _soycontrollersVirtualControllerClass soycontrollersVirtualControllerClass;
typedef struct _soycontrollersVirtualControllerPrivate soycontrollersVirtualControllerPrivate;

#define SOY_SCENES_TYPE_SCENE (soy_scenes_scene_get_type ())
#define SOY_SCENES_SCENE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_SCENES_TYPE_SCENE, soyscenesScene))
#define SOY_SCENES_SCENE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_SCENES_TYPE_SCENE, soyscenesSceneClass))
#define SOY_SCENES_IS_SCENE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_SCENES_TYPE_SCENE))
#define SOY_SCENES_IS_SCENE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_SCENES_TYPE_SCENE))
#define SOY_SCENES_SCENE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_SCENES_TYPE_SCENE, soyscenesSceneClass))

typedef struct _soyscenesScene soyscenesScene;
typedef struct _soyscenesSceneClass soyscenesSceneClass;

#define SOY_CONTROLLERS_TYPE_PATHFOLLOWER (soy_controllers_pathfollower_get_type ())
#define SOY_CONTROLLERS_PATHFOLLOWER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_CONTROLLERS_TYPE_PATHFOLLOWER, soycontrollersPathfollower))
#define SOY_CONTROLLERS_PATHFOLLOWER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_CONTROLLERS_TYPE_PATHFOLLOWER, soycontrollersPathfollowerClass))
#define SOY_CONTROLLERS_IS_PATHFOLLOWER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_CONTROLLERS_TYPE_PATHFOLLOWER))
#define SOY_CONTROLLERS_IS_PATHFOLLOWER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_CONTROLLERS_TYPE_PATHFOLLOWER))
#define SOY_CONTROLLERS_PATHFOLLOWER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_CONTROLLERS_TYPE_PATHFOLLOWER, soycontrollersPathfollowerClass))

typedef struct _soycontrollersPathfollower soycontrollersPathfollower;
typedef struct _soycontrollersPathfollowerClass soycontrollersPathfollowerClass;
typedef struct _soycontrollersPathfollowerPrivate soycontrollersPathfollowerPrivate;

#define SOY_ATOMS_TYPE_VECTOR (soy_atoms_vector_get_type ())
#define SOY_ATOMS_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_VECTOR, soyatomsVector))
#define SOY_ATOMS_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_VECTOR, soyatomsVectorClass))
#define SOY_ATOMS_IS_VECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_VECTOR))
#define SOY_ATOMS_IS_VECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_VECTOR))
#define SOY_ATOMS_VECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_VECTOR, soyatomsVectorClass))

typedef struct _soyatomsVector soyatomsVector;
typedef struct _soyatomsVectorClass soyatomsVectorClass;

#define SOY_BODIES_TYPE_BODY (soy_bodies_body_get_type ())
#define SOY_BODIES_BODY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_BODIES_TYPE_BODY, soybodiesBody))
#define SOY_BODIES_BODY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_BODIES_TYPE_BODY, soybodiesBodyClass))
#define SOY_BODIES_IS_BODY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_BODIES_TYPE_BODY))
#define SOY_BODIES_IS_BODY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_BODIES_TYPE_BODY))
#define SOY_BODIES_BODY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_BODIES_TYPE_BODY, soybodiesBodyClass))

typedef struct _soybodiesBody soybodiesBody;
typedef struct _soybodiesBodyClass soybodiesBodyClass;

#define SOY_ATOMS_TYPE_POSITION (soy_atoms_position_get_type ())
#define SOY_ATOMS_POSITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_POSITION, soyatomsPosition))
#define SOY_ATOMS_POSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_POSITION, soyatomsPositionClass))
#define SOY_ATOMS_IS_POSITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_POSITION))
#define SOY_ATOMS_IS_POSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_POSITION))
#define SOY_ATOMS_POSITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_POSITION, soyatomsPositionClass))

typedef struct _soyatomsPosition soyatomsPosition;
typedef struct _soyatomsPositionClass soyatomsPositionClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _soybodiesBodyPrivate soybodiesBodyPrivate;

#define SOY_BODIES_TYPE_CAMERA (soy_bodies_camera_get_type ())
#define SOY_BODIES_CAMERA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_BODIES_TYPE_CAMERA, soybodiesCamera))
#define SOY_BODIES_CAMERA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_BODIES_TYPE_CAMERA, soybodiesCameraClass))
#define SOY_BODIES_IS_CAMERA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_BODIES_TYPE_CAMERA))
#define SOY_BODIES_IS_CAMERA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_BODIES_TYPE_CAMERA))
#define SOY_BODIES_CAMERA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_BODIES_TYPE_CAMERA, soybodiesCameraClass))

typedef struct _soybodiesCamera soybodiesCamera;
typedef struct _soybodiesCameraClass soybodiesCameraClass;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _soycontrollersController {
	GObject parent_instance;
	soycontrollersControllerPrivate * priv;
};

struct _soycontrollersControllerClass {
	GObjectClass parent_class;
	gchar* (*tp_repr) (soycontrollersController* self);
};

struct _soycontrollersVirtualController {
	soycontrollersController parent_instance;
	soycontrollersVirtualControllerPrivate * priv;
	soyscenesScene* scene;
};

struct _soycontrollersVirtualControllerClass {
	soycontrollersControllerClass parent_class;
	void (*run_controller) (soycontrollersVirtualController* self);
	void (*unregister_controller) (soycontrollersVirtualController* self);
	void (*register_controller) (soycontrollersVirtualController* self);
	gboolean (*get_registered) (soycontrollersVirtualController* self);
	void (*set_registered) (soycontrollersVirtualController* self, gboolean value);
	gboolean (*get_finished) (soycontrollersVirtualController* self);
};

struct _soycontrollersPathfollower {
	soycontrollersVirtualController parent_instance;
	soycontrollersPathfollowerPrivate * priv;
	soybodiesBody* controlled;
	GRecMutex path_lock;
	GMutex pause_lock;
};

struct _soycontrollersPathfollowerClass {
	soycontrollersVirtualControllerClass parent_class;
	void (*path_finished) (soycontrollersPathfollower* self, struct dxBody* body);
	void (*waypoint_reached) (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist);
	void (*between_waypoints) (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist);
	void (*skipped) (soycontrollersPathfollower* self, struct dxBody* body);
	gfloat (*get_speed) (soycontrollersPathfollower* self);
	void (*set_speed) (soycontrollersPathfollower* self, gfloat value);
};

struct _soycontrollersPathfollowerPrivate {
	GeeIterable* _path;
	GeeIterator* _iter_path;
	gboolean _iter_valid;
	gfloat _speed;
	gboolean _finished;
	gboolean _paused;
	gfloat _fuzziness;
};

struct _soybodiesBody {
	GObject parent_instance;
	soybodiesBodyPrivate * priv;
	struct dxBody* body;
	GLfloat* fogcoords;
	gint fogcoords_length1;
	struct dxGeom* geom;
	gchar* key;
	GMutex mutex;
	GLfloat* tslvs;
	gint tslvs_length1;
	soyscenesScene* scene;
	GeeHashMap* tags_;
};

struct _soybodiesBodyClass {
	GObjectClass parent_class;
	void (*create_geom) (soybodiesBody* self, GObject* geom_param, gfloat geom_scalar);
	void (*set_mass) (soybodiesBody* self, gfloat density);
	void (*add_extra) (soybodiesBody* self);
	void (*remove_extra) (soybodiesBody* self);
	gfloat (*pointDepth) (soybodiesBody* self, gfloat x, gfloat y, gfloat z);
	gfloat (*volume) (soybodiesBody* self);
	gint (*finite) (soybodiesBody* self);
	void (*mult_model_matrix) (soybodiesBody* self);
	void (*render) (soybodiesBody* self, gboolean alpha_stage, soybodiesCamera* camera, gint level);
	gfloat (*get_col_radius) (soybodiesBody* self);
};


static gpointer soy_controllers_pathfollower_parent_class = NULL;
extern GRWLock soy_scenes__stepLock;

GType soy_controllers_controller_get_type (void) G_GNUC_CONST;
GType soy_controllers_virtual_controller_get_type (void) G_GNUC_CONST;
GType soy_scenes_scene_get_type (void) G_GNUC_CONST;
GType soy_controllers_pathfollower_get_type (void) G_GNUC_CONST;
GType soy_atoms_vector_get_type (void) G_GNUC_CONST;
GType soy_bodies_body_get_type (void) G_GNUC_CONST;
GType soy_atoms_position_get_type (void) G_GNUC_CONST;
#define SOY_CONTROLLERS_PATHFOLLOWER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SOY_CONTROLLERS_TYPE_PATHFOLLOWER, soycontrollersPathfollowerPrivate))
enum  {
	SOY_CONTROLLERS_PATHFOLLOWER_DUMMY_PROPERTY,
	SOY_CONTROLLERS_PATHFOLLOWER_PATH,
	SOY_CONTROLLERS_PATHFOLLOWER_SPEED,
	SOY_CONTROLLERS_PATHFOLLOWER_FINISHED,
	SOY_CONTROLLERS_PATHFOLLOWER_PAUSED,
	SOY_CONTROLLERS_PATHFOLLOWER_FUZZINESS
};
soycontrollersPathfollower* soy_controllers_pathfollower_new (soyscenesScene* scene, soybodiesBody* controlled, gfloat speed, gfloat fuzziness, gboolean paused, GeeIterable* path);
soycontrollersPathfollower* soy_controllers_pathfollower_construct (GType object_type, soyscenesScene* scene, soybodiesBody* controlled, gfloat speed, gfloat fuzziness, gboolean paused, GeeIterable* path);
soycontrollersVirtualController* soy_controllers_virtual_controller_new (soyscenesScene* scene);
soycontrollersVirtualController* soy_controllers_virtual_controller_construct (GType object_type, soyscenesScene* scene);
static gchar* soy_controllers_pathfollower_real_tp_repr (soycontrollersController* base);
void soy_controllers_pathfollower_path_finished (soycontrollersPathfollower* self, struct dxBody* body);
static void soy_controllers_pathfollower_real_path_finished (soycontrollersPathfollower* self, struct dxBody* body);
void soy_controllers_pathfollower_waypoint_reached (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist);
static void soy_controllers_pathfollower_real_waypoint_reached (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist);
void soy_controllers_pathfollower_between_waypoints (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist);
static void soy_controllers_pathfollower_real_between_waypoints (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist);
gfloat soy_controllers_pathfollower_get_speed (soycontrollersPathfollower* self);
gfloat soy_atoms_vector_get_x (soyatomsVector* self);
gfloat soy_atoms_vector_get_y (soyatomsVector* self);
gfloat soy_atoms_vector_get_z (soyatomsVector* self);
void soy_controllers_pathfollower_skipped (soycontrollersPathfollower* self, struct dxBody* body);
static void soy_controllers_pathfollower_real_skipped (soycontrollersPathfollower* self, struct dxBody* body);
gboolean soy_controllers_pathfollower_get_paused (soycontrollersPathfollower* self);
static void soy_controllers_pathfollower_real_run_controller (soycontrollersVirtualController* base);
GType soy_bodies_camera_get_type (void) G_GNUC_CONST;
gfloat soy_atoms_position_get_x (soyatomsPosition* self);
gfloat soy_atoms_position_get_y (soyatomsPosition* self);
gfloat soy_atoms_position_get_z (soyatomsPosition* self);
soyatomsVector* soy_atoms_vector_new (gfloat x, gfloat y, gfloat z);
soyatomsVector* soy_atoms_vector_construct (GType object_type, gfloat x, gfloat y, gfloat z);
static void soy_controllers_pathfollower_real_unregister_controller (soycontrollersVirtualController* base);
void soy_controllers_virtual_controller_unregister_controller (soycontrollersVirtualController* self);
GeeIterable* soy_controllers_pathfollower_get_path (soycontrollersPathfollower* self);
void soy_controllers_pathfollower_set_path (soycontrollersPathfollower* self, GeeIterable* value);
void soy_controllers_virtual_controller_set_registered (soycontrollersVirtualController* self, gboolean value);
void soy_controllers_pathfollower_set_speed (soycontrollersPathfollower* self, gfloat value);
void soy_controllers_pathfollower_set_paused (soycontrollersPathfollower* self, gboolean value);
gfloat soy_controllers_pathfollower_get_fuzziness (soycontrollersPathfollower* self);
void soy_controllers_pathfollower_set_fuzziness (soycontrollersPathfollower* self, gfloat value);
static void soy_controllers_pathfollower_finalize (GObject* obj);
gboolean soy_controllers_virtual_controller_get_finished (soycontrollersVirtualController* self);
static void _vala_soy_controllers_pathfollower_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_soy_controllers_pathfollower_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_clear_GMutex (GMutex * mutex);
static void _vala_clear_GRecMutex (GRecMutex * mutex);
static void _vala_clear_GRWLock (GRWLock * mutex);
static void _vala_clear_GCond (GCond * mutex);


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


soycontrollersPathfollower* soy_controllers_pathfollower_construct (GType object_type, soyscenesScene* scene, soybodiesBody* controlled, gfloat speed, gfloat fuzziness, gboolean paused, GeeIterable* path) {
	soycontrollersPathfollower * self = NULL;
	soyscenesScene* _tmp0_;
	gfloat _tmp1_;
	soybodiesBody* _tmp2_;
	soybodiesBody* _tmp3_;
	gfloat _tmp4_;
	GeeIterable* _tmp5_;
	GeeIterator* _tmp6_ = NULL;
	GeeIterable* _tmp7_;
	GeeIterable* _tmp8_;
	GeeIterator* _tmp9_;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp12_;
	g_return_val_if_fail (scene != NULL, NULL);
	g_return_val_if_fail (controlled != NULL, NULL);
	g_return_val_if_fail (path != NULL, NULL);
	_tmp0_ = scene;
	self = (soycontrollersPathfollower*) soy_controllers_virtual_controller_construct (object_type, _tmp0_);
	_vala_clear_GRecMutex (&self->path_lock);
	g_rec_mutex_init (&self->path_lock);
	_vala_clear_GMutex (&self->pause_lock);
	g_mutex_init (&self->pause_lock);
	self->priv->_paused = TRUE;
	g_rec_mutex_lock (&self->path_lock);
	self->priv->_finished = FALSE;
	_tmp1_ = speed;
	self->priv->_speed = _tmp1_;
	_tmp2_ = controlled;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->controlled);
	self->controlled = _tmp3_;
	_tmp4_ = fuzziness;
	self->priv->_fuzziness = _tmp4_;
	_tmp5_ = path;
	_tmp6_ = gee_iterable_iterator (_tmp5_);
	_g_object_unref0 (self->priv->_iter_path);
	self->priv->_iter_path = _tmp6_;
	_tmp7_ = path;
	_tmp8_ = _g_object_ref0 (_tmp7_);
	_g_object_unref0 (self->priv->_path);
	self->priv->_path = _tmp8_;
	_tmp9_ = self->priv->_iter_path;
	_tmp10_ = gee_iterator_has_next (_tmp9_);
	if (_tmp10_) {
		GeeIterator* _tmp11_;
		_tmp11_ = self->priv->_iter_path;
		gee_iterator_next (_tmp11_);
		self->priv->_iter_valid = TRUE;
	}
	_tmp12_ = paused;
	if (!_tmp12_) {
		self->priv->_paused = FALSE;
		g_rec_mutex_unlock (&self->path_lock);
	}
	return self;
}


soycontrollersPathfollower* soy_controllers_pathfollower_new (soyscenesScene* scene, soybodiesBody* controlled, gfloat speed, gfloat fuzziness, gboolean paused, GeeIterable* path) {
	return soy_controllers_pathfollower_construct (SOY_CONTROLLERS_TYPE_PATHFOLLOWER, scene, controlled, speed, fuzziness, paused, path);
}


static gchar* soy_controllers_pathfollower_real_tp_repr (soycontrollersController* base) {
	soycontrollersPathfollower * self;
	gchar* result = NULL;
	gchar* _tmp0_;
	self = (soycontrollersPathfollower*) base;
	_tmp0_ = g_strdup ("Generic pathfollower virtual controller");
	result = _tmp0_;
	return result;
}


static void soy_controllers_pathfollower_real_path_finished (soycontrollersPathfollower* self, struct dxBody* body) {
	struct dxBody* _tmp0_;
	g_return_if_fail (body != NULL);
	_tmp0_ = body;
	dBodySetLinearVel (_tmp0_, (dReal) 0.0f, (dReal) 0.0f, (dReal) 0.0f);
	return;
}


void soy_controllers_pathfollower_path_finished (soycontrollersPathfollower* self, struct dxBody* body) {
	g_return_if_fail (self != NULL);
	SOY_CONTROLLERS_PATHFOLLOWER_GET_CLASS (self)->path_finished (self, body);
}


static void soy_controllers_pathfollower_real_waypoint_reached (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist) {
	struct dxBody* _tmp0_;
	soyatomsVector* _tmp1_;
	gfloat _tmp2_;
	g_return_if_fail (body != NULL);
	g_return_if_fail (next_vec != NULL);
	_tmp0_ = body;
	_tmp1_ = next_vec;
	_tmp2_ = dist;
	soy_controllers_pathfollower_between_waypoints (self, _tmp0_, _tmp1_, _tmp2_);
	return;
}


void soy_controllers_pathfollower_waypoint_reached (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist) {
	g_return_if_fail (self != NULL);
	SOY_CONTROLLERS_PATHFOLLOWER_GET_CLASS (self)->waypoint_reached (self, body, next_vec, dist);
}


static void soy_controllers_pathfollower_real_between_waypoints (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist) {
	gfloat _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_ = 0.0F;
	gfloat spd;
	struct dxBody* _tmp4_;
	soyatomsVector* _tmp5_;
	gfloat _tmp6_;
	gfloat _tmp7_;
	soyatomsVector* _tmp8_;
	gfloat _tmp9_;
	gfloat _tmp10_;
	soyatomsVector* _tmp11_;
	gfloat _tmp12_;
	gfloat _tmp13_;
	g_return_if_fail (body != NULL);
	g_return_if_fail (next_vec != NULL);
	_tmp0_ = dist;
	_tmp1_ = soy_controllers_pathfollower_get_speed (self);
	_tmp2_ = _tmp1_;
	_tmp3_ = fminf (_tmp0_ * 100.0f, _tmp2_);
	spd = _tmp3_;
	_tmp4_ = body;
	_tmp5_ = next_vec;
	_tmp6_ = soy_atoms_vector_get_x (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = next_vec;
	_tmp9_ = soy_atoms_vector_get_y (_tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = next_vec;
	_tmp12_ = soy_atoms_vector_get_z (_tmp11_);
	_tmp13_ = _tmp12_;
	dBodySetLinearVel (_tmp4_, (dReal) (_tmp7_ * spd), (dReal) (_tmp10_ * spd), (dReal) (_tmp13_ * spd));
	return;
}


void soy_controllers_pathfollower_between_waypoints (soycontrollersPathfollower* self, struct dxBody* body, soyatomsVector* next_vec, gfloat dist) {
	g_return_if_fail (self != NULL);
	SOY_CONTROLLERS_PATHFOLLOWER_GET_CLASS (self)->between_waypoints (self, body, next_vec, dist);
}


static void soy_controllers_pathfollower_real_skipped (soycontrollersPathfollower* self, struct dxBody* body) {
	gboolean _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (body != NULL);
	_tmp0_ = soy_controllers_pathfollower_get_paused (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_) {
		struct dxBody* _tmp2_;
		_tmp2_ = body;
		dBodySetLinearVel (_tmp2_, (dReal) 0.0f, (dReal) 0.0f, (dReal) 0.0f);
	}
	return;
}


void soy_controllers_pathfollower_skipped (soycontrollersPathfollower* self, struct dxBody* body) {
	g_return_if_fail (self != NULL);
	SOY_CONTROLLERS_PATHFOLLOWER_GET_CLASS (self)->skipped (self, body);
}


static void soy_controllers_pathfollower_real_run_controller (soycontrollersVirtualController* base) {
	soycontrollersPathfollower * self;
	gboolean _tmp0_;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	gboolean _tmp4_;
	gboolean _tmp7_;
	soybodiesBody* _tmp10_;
	struct dxBody* _tmp11_;
	dxVector3* _tmp12_ = NULL;
	dxVector3* cur;
	GeeIterator* _tmp13_;
	gpointer _tmp14_ = NULL;
	soyatomsPosition* next;
	dxVector3* _tmp15_;
	dReal _tmp16_;
	soyatomsPosition* _tmp17_;
	gfloat _tmp18_;
	gfloat _tmp19_;
	dxVector3* _tmp20_;
	dReal _tmp21_;
	soyatomsPosition* _tmp22_;
	gfloat _tmp23_;
	gfloat _tmp24_;
	gfloat _tmp25_ = 0.0F;
	dxVector3* _tmp26_;
	dReal _tmp27_;
	soyatomsPosition* _tmp28_;
	gfloat _tmp29_;
	gfloat _tmp30_;
	gfloat _tmp31_ = 0.0F;
	gfloat dist;
	soyatomsVector* vec = NULL;
	gfloat _tmp32_;
	gfloat _tmp33_;
	self = (soycontrollersPathfollower*) base;
	_tmp0_ = self->priv->_finished;
	if (_tmp0_) {
		return;
	}
	_tmp2_ = self->priv->_paused;
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = g_rec_mutex_trylock (&self->path_lock);
		_tmp1_ = !_tmp3_;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		soybodiesBody* _tmp5_;
		struct dxBody* _tmp6_;
		_tmp5_ = self->controlled;
		_tmp6_ = _tmp5_->body;
		soy_controllers_pathfollower_skipped (self, _tmp6_);
		return;
	}
	_tmp7_ = self->priv->_iter_valid;
	if (!_tmp7_) {
		soybodiesBody* _tmp8_;
		struct dxBody* _tmp9_;
		g_rec_mutex_unlock (&self->path_lock);
		self->priv->_finished = TRUE;
		_tmp8_ = self->controlled;
		_tmp9_ = _tmp8_->body;
		soy_controllers_pathfollower_path_finished (self, _tmp9_);
		return;
	}
	_tmp10_ = self->controlled;
	_tmp11_ = _tmp10_->body;
	_tmp12_ = dBodyGetPosition (_tmp11_);
	cur = _tmp12_;
	_tmp13_ = self->priv->_iter_path;
	_tmp14_ = gee_iterator_get (_tmp13_);
	next = (soyatomsPosition*) _tmp14_;
	_tmp15_ = cur;
	_tmp16_ = _tmp15_->x;
	_tmp17_ = next;
	_tmp18_ = soy_atoms_position_get_x (_tmp17_);
	_tmp19_ = _tmp18_;
	_tmp20_ = cur;
	_tmp21_ = _tmp20_->y;
	_tmp22_ = next;
	_tmp23_ = soy_atoms_position_get_y (_tmp22_);
	_tmp24_ = _tmp23_;
	_tmp25_ = hypotf (((gfloat) _tmp16_) - _tmp19_, ((gfloat) _tmp21_) - _tmp24_);
	_tmp26_ = cur;
	_tmp27_ = _tmp26_->z;
	_tmp28_ = next;
	_tmp29_ = soy_atoms_position_get_z (_tmp28_);
	_tmp30_ = _tmp29_;
	_tmp31_ = hypotf (_tmp25_, ((gfloat) _tmp27_) - _tmp30_);
	dist = _tmp31_;
	_tmp32_ = dist;
	_tmp33_ = self->priv->_fuzziness;
	if (_tmp32_ < _tmp33_) {
		GeeIterator* _tmp34_;
		GeeIterator* _tmp35_;
		gboolean _tmp36_ = FALSE;
		GeeIterator* _tmp39_;
		GeeIterator* _tmp40_;
		gpointer _tmp41_ = NULL;
		dxVector3* _tmp42_;
		dReal _tmp43_;
		soyatomsPosition* _tmp44_;
		gfloat _tmp45_;
		gfloat _tmp46_;
		dxVector3* _tmp47_;
		dReal _tmp48_;
		soyatomsPosition* _tmp49_;
		gfloat _tmp50_;
		gfloat _tmp51_;
		gfloat _tmp52_ = 0.0F;
		dxVector3* _tmp53_;
		dReal _tmp54_;
		soyatomsPosition* _tmp55_;
		gfloat _tmp56_;
		gfloat _tmp57_;
		gfloat _tmp58_ = 0.0F;
		gfloat _tmp59_;
		soybodiesBody* _tmp80_;
		struct dxBody* _tmp81_;
		soyatomsVector* _tmp82_;
		gfloat _tmp83_;
		_tmp34_ = self->priv->_iter_path;
		gee_iterator_remove (_tmp34_);
		_tmp35_ = self->priv->_iter_path;
		_tmp36_ = gee_iterator_has_next (_tmp35_);
		if (!_tmp36_) {
			soybodiesBody* _tmp37_;
			struct dxBody* _tmp38_;
			g_rec_mutex_unlock (&self->path_lock);
			self->priv->_finished = TRUE;
			_tmp37_ = self->controlled;
			_tmp38_ = _tmp37_->body;
			soy_controllers_pathfollower_path_finished (self, _tmp38_);
			_g_object_unref0 (vec);
			_g_object_unref0 (next);
			return;
		}
		_tmp39_ = self->priv->_iter_path;
		gee_iterator_next (_tmp39_);
		_tmp40_ = self->priv->_iter_path;
		_tmp41_ = gee_iterator_get (_tmp40_);
		_g_object_unref0 (next);
		next = (soyatomsPosition*) _tmp41_;
		g_rec_mutex_unlock (&self->path_lock);
		_tmp42_ = cur;
		_tmp43_ = _tmp42_->x;
		_tmp44_ = next;
		_tmp45_ = soy_atoms_position_get_x (_tmp44_);
		_tmp46_ = _tmp45_;
		_tmp47_ = cur;
		_tmp48_ = _tmp47_->y;
		_tmp49_ = next;
		_tmp50_ = soy_atoms_position_get_y (_tmp49_);
		_tmp51_ = _tmp50_;
		_tmp52_ = hypotf (((gfloat) _tmp43_) - _tmp46_, ((gfloat) _tmp48_) - _tmp51_);
		_tmp53_ = cur;
		_tmp54_ = _tmp53_->z;
		_tmp55_ = next;
		_tmp56_ = soy_atoms_position_get_z (_tmp55_);
		_tmp57_ = _tmp56_;
		_tmp58_ = hypotf (_tmp52_, ((gfloat) _tmp54_) - _tmp57_);
		dist = _tmp58_;
		_tmp59_ = dist;
		if (_tmp59_ == 0.0f) {
			soyatomsVector* _tmp60_;
			_tmp60_ = soy_atoms_vector_new (0.0f, 0.0f, 0.0f);
			_g_object_unref0 (vec);
			vec = _tmp60_;
		} else {
			soyatomsPosition* _tmp61_;
			gfloat _tmp62_;
			gfloat _tmp63_;
			dxVector3* _tmp64_;
			dReal _tmp65_;
			gfloat _tmp66_;
			soyatomsPosition* _tmp67_;
			gfloat _tmp68_;
			gfloat _tmp69_;
			dxVector3* _tmp70_;
			dReal _tmp71_;
			gfloat _tmp72_;
			soyatomsPosition* _tmp73_;
			gfloat _tmp74_;
			gfloat _tmp75_;
			dxVector3* _tmp76_;
			dReal _tmp77_;
			gfloat _tmp78_;
			soyatomsVector* _tmp79_;
			_tmp61_ = next;
			_tmp62_ = soy_atoms_position_get_x (_tmp61_);
			_tmp63_ = _tmp62_;
			_tmp64_ = cur;
			_tmp65_ = _tmp64_->x;
			_tmp66_ = dist;
			_tmp67_ = next;
			_tmp68_ = soy_atoms_position_get_y (_tmp67_);
			_tmp69_ = _tmp68_;
			_tmp70_ = cur;
			_tmp71_ = _tmp70_->y;
			_tmp72_ = dist;
			_tmp73_ = next;
			_tmp74_ = soy_atoms_position_get_z (_tmp73_);
			_tmp75_ = _tmp74_;
			_tmp76_ = cur;
			_tmp77_ = _tmp76_->z;
			_tmp78_ = dist;
			_tmp79_ = soy_atoms_vector_new ((_tmp63_ - ((gfloat) _tmp65_)) / _tmp66_, (_tmp69_ - ((gfloat) _tmp71_)) / _tmp72_, (_tmp75_ - ((gfloat) _tmp77_)) / _tmp78_);
			_g_object_unref0 (vec);
			vec = _tmp79_;
		}
		_tmp80_ = self->controlled;
		_tmp81_ = _tmp80_->body;
		_tmp82_ = vec;
		_tmp83_ = dist;
		soy_controllers_pathfollower_waypoint_reached (self, _tmp81_, _tmp82_, _tmp83_);
	} else {
		soyatomsPosition* _tmp84_;
		gfloat _tmp85_;
		gfloat _tmp86_;
		dxVector3* _tmp87_;
		dReal _tmp88_;
		gfloat _tmp89_;
		soyatomsPosition* _tmp90_;
		gfloat _tmp91_;
		gfloat _tmp92_;
		dxVector3* _tmp93_;
		dReal _tmp94_;
		gfloat _tmp95_;
		soyatomsPosition* _tmp96_;
		gfloat _tmp97_;
		gfloat _tmp98_;
		dxVector3* _tmp99_;
		dReal _tmp100_;
		gfloat _tmp101_;
		soyatomsVector* _tmp102_;
		soybodiesBody* _tmp103_;
		struct dxBody* _tmp104_;
		soyatomsVector* _tmp105_;
		gfloat _tmp106_;
		g_rec_mutex_unlock (&self->path_lock);
		_tmp84_ = next;
		_tmp85_ = soy_atoms_position_get_x (_tmp84_);
		_tmp86_ = _tmp85_;
		_tmp87_ = cur;
		_tmp88_ = _tmp87_->x;
		_tmp89_ = dist;
		_tmp90_ = next;
		_tmp91_ = soy_atoms_position_get_y (_tmp90_);
		_tmp92_ = _tmp91_;
		_tmp93_ = cur;
		_tmp94_ = _tmp93_->y;
		_tmp95_ = dist;
		_tmp96_ = next;
		_tmp97_ = soy_atoms_position_get_z (_tmp96_);
		_tmp98_ = _tmp97_;
		_tmp99_ = cur;
		_tmp100_ = _tmp99_->z;
		_tmp101_ = dist;
		_tmp102_ = soy_atoms_vector_new ((_tmp86_ - ((gfloat) _tmp88_)) / _tmp89_, (_tmp92_ - ((gfloat) _tmp94_)) / _tmp95_, (_tmp98_ - ((gfloat) _tmp100_)) / _tmp101_);
		_g_object_unref0 (vec);
		vec = _tmp102_;
		_tmp103_ = self->controlled;
		_tmp104_ = _tmp103_->body;
		_tmp105_ = vec;
		_tmp106_ = dist;
		soy_controllers_pathfollower_between_waypoints (self, _tmp104_, _tmp105_, _tmp106_);
	}
	_g_object_unref0 (vec);
	_g_object_unref0 (next);
}


static void soy_controllers_pathfollower_real_unregister_controller (soycontrollersVirtualController* base) {
	soycontrollersPathfollower * self;
	soybodiesBody* _tmp0_;
	struct dxBody* _tmp1_;
	self = (soycontrollersPathfollower*) base;
	SOY_CONTROLLERS_VIRTUAL_CONTROLLER_CLASS (soy_controllers_pathfollower_parent_class)->unregister_controller (G_TYPE_CHECK_INSTANCE_CAST (self, SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, soycontrollersVirtualController));
	g_rw_lock_writer_lock (&soy_scenes__stepLock);
	_tmp0_ = self->controlled;
	_tmp1_ = _tmp0_->body;
	soy_controllers_pathfollower_path_finished (self, _tmp1_);
	g_rw_lock_writer_unlock (&soy_scenes__stepLock);
}


GeeIterable* soy_controllers_pathfollower_get_path (soycontrollersPathfollower* self) {
	GeeIterable* result;
	GeeIterable* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_path;
	result = _tmp0_;
	return result;
}


void soy_controllers_pathfollower_set_path (soycontrollersPathfollower* self, GeeIterable* value) {
	GeeIterable* _tmp0_;
	GeeIterable* _tmp1_;
	GeeIterable* _tmp2_;
	GeeIterator* _tmp3_ = NULL;
	GeeIterator* _tmp4_;
	gboolean _tmp5_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_path);
	self->priv->_path = _tmp1_;
	_tmp2_ = value;
	_tmp3_ = gee_iterable_iterator (_tmp2_);
	_g_object_unref0 (self->priv->_iter_path);
	self->priv->_iter_path = _tmp3_;
	_tmp4_ = self->priv->_iter_path;
	_tmp5_ = gee_iterator_has_next (_tmp4_);
	if (!_tmp5_) {
		self->priv->_iter_valid = FALSE;
		self->priv->_finished = TRUE;
		soy_controllers_virtual_controller_set_registered ((soycontrollersVirtualController*) self, FALSE);
	} else {
		GeeIterator* _tmp6_;
		_tmp6_ = self->priv->_iter_path;
		gee_iterator_next (_tmp6_);
		self->priv->_iter_valid = TRUE;
		self->priv->_finished = FALSE;
		soy_controllers_virtual_controller_set_registered ((soycontrollersVirtualController*) self, TRUE);
	}
	g_object_notify ((GObject *) self, "path");
}


gfloat soy_controllers_pathfollower_get_speed (soycontrollersPathfollower* self) {
	g_return_val_if_fail (self != NULL, 0.0F);
	return SOY_CONTROLLERS_PATHFOLLOWER_GET_CLASS (self)->get_speed (self);
}


static gfloat soy_controllers_pathfollower_real_get_speed (soycontrollersPathfollower* base) {
	gfloat result;
	soycontrollersPathfollower* self;
	gfloat _tmp0_;
	self = base;
	_tmp0_ = self->priv->_speed;
	result = _tmp0_;
	return result;
}


void soy_controllers_pathfollower_set_speed (soycontrollersPathfollower* self, gfloat value) {
	g_return_if_fail (self != NULL);
	SOY_CONTROLLERS_PATHFOLLOWER_GET_CLASS (self)->set_speed (self, value);
}


static void soy_controllers_pathfollower_real_set_speed (soycontrollersPathfollower* base, gfloat value) {
	soycontrollersPathfollower* self;
	gfloat _tmp0_;
	gfloat _tmp1_;
	self = base;
	_tmp0_ = value;
	_vala_assert (_tmp0_ > 0.0f, "value > 0.0f");
	_tmp1_ = value;
	self->priv->_speed = _tmp1_;
	g_object_notify ((GObject *) self, "speed");
}


static gboolean soy_controllers_pathfollower_real_get_finished (soycontrollersVirtualController* base) {
	gboolean result;
	soycontrollersPathfollower* self;
	gboolean _tmp0_;
	self = (soycontrollersPathfollower*) base;
	_tmp0_ = self->priv->_finished;
	result = _tmp0_;
	return result;
}


gboolean soy_controllers_pathfollower_get_paused (soycontrollersPathfollower* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_paused;
	result = _tmp0_;
	return result;
}


void soy_controllers_pathfollower_set_paused (soycontrollersPathfollower* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	gboolean _tmp3_;
	g_return_if_fail (self != NULL);
	g_mutex_lock (&self->pause_lock);
	_tmp1_ = self->priv->_paused;
	if (_tmp1_) {
		gboolean _tmp2_;
		_tmp2_ = value;
		_tmp0_ = !_tmp2_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		g_rec_mutex_unlock (&self->path_lock);
		self->priv->_paused = FALSE;
	} else {
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_;
		gboolean _tmp7_;
		_tmp5_ = self->priv->_paused;
		if (!_tmp5_) {
			gboolean _tmp6_;
			_tmp6_ = value;
			_tmp4_ = _tmp6_;
		} else {
			_tmp4_ = FALSE;
		}
		_tmp7_ = _tmp4_;
		if (_tmp7_) {
			g_rec_mutex_lock (&self->path_lock);
			self->priv->_paused = TRUE;
		}
	}
	g_mutex_unlock (&self->pause_lock);
	g_object_notify ((GObject *) self, "paused");
}


gfloat soy_controllers_pathfollower_get_fuzziness (soycontrollersPathfollower* self) {
	gfloat result;
	gfloat _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->priv->_fuzziness;
	result = _tmp0_;
	return result;
}


void soy_controllers_pathfollower_set_fuzziness (soycontrollersPathfollower* self, gfloat value) {
	gfloat _tmp0_;
	gfloat _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_vala_assert (_tmp0_ > 0.0f, "value > 0.0f");
	_tmp1_ = value;
	self->priv->_fuzziness = _tmp1_;
	g_object_notify ((GObject *) self, "fuzziness");
}


static void soy_controllers_pathfollower_class_init (soycontrollersPathfollowerClass * klass) {
	soy_controllers_pathfollower_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (soycontrollersPathfollowerPrivate));
	SOY_CONTROLLERS_CONTROLLER_CLASS (klass)->tp_repr = soy_controllers_pathfollower_real_tp_repr;
	SOY_CONTROLLERS_PATHFOLLOWER_CLASS (klass)->path_finished = soy_controllers_pathfollower_real_path_finished;
	SOY_CONTROLLERS_PATHFOLLOWER_CLASS (klass)->waypoint_reached = soy_controllers_pathfollower_real_waypoint_reached;
	SOY_CONTROLLERS_PATHFOLLOWER_CLASS (klass)->between_waypoints = soy_controllers_pathfollower_real_between_waypoints;
	SOY_CONTROLLERS_PATHFOLLOWER_CLASS (klass)->skipped = soy_controllers_pathfollower_real_skipped;
	SOY_CONTROLLERS_VIRTUAL_CONTROLLER_CLASS (klass)->run_controller = soy_controllers_pathfollower_real_run_controller;
	SOY_CONTROLLERS_VIRTUAL_CONTROLLER_CLASS (klass)->unregister_controller = soy_controllers_pathfollower_real_unregister_controller;
	SOY_CONTROLLERS_PATHFOLLOWER_CLASS (klass)->get_speed = soy_controllers_pathfollower_real_get_speed;
	SOY_CONTROLLERS_PATHFOLLOWER_CLASS (klass)->set_speed = soy_controllers_pathfollower_real_set_speed;
	SOY_CONTROLLERS_VIRTUAL_CONTROLLER_CLASS (klass)->get_finished = soy_controllers_pathfollower_real_get_finished;
	G_OBJECT_CLASS (klass)->get_property = _vala_soy_controllers_pathfollower_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_soy_controllers_pathfollower_set_property;
	G_OBJECT_CLASS (klass)->finalize = soy_controllers_pathfollower_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_CONTROLLERS_PATHFOLLOWER_PATH, g_param_spec_object ("path", "path", "path", GEE_TYPE_ITERABLE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_CONTROLLERS_PATHFOLLOWER_SPEED, g_param_spec_float ("speed", "speed", "speed", -G_MAXFLOAT, G_MAXFLOAT, 0.0F, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_CONTROLLERS_PATHFOLLOWER_FINISHED, g_param_spec_boolean ("finished", "finished", "finished", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_CONTROLLERS_PATHFOLLOWER_PAUSED, g_param_spec_boolean ("paused", "paused", "paused", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_CONTROLLERS_PATHFOLLOWER_FUZZINESS, g_param_spec_float ("fuzziness", "fuzziness", "fuzziness", -G_MAXFLOAT, G_MAXFLOAT, 0.0F, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void soy_controllers_pathfollower_instance_init (soycontrollersPathfollower * self) {
	self->priv = SOY_CONTROLLERS_PATHFOLLOWER_GET_PRIVATE (self);
	self->priv->_iter_valid = FALSE;
	self->priv->_finished = FALSE;
	self->priv->_paused = TRUE;
}


static void soy_controllers_pathfollower_finalize (GObject* obj) {
	soycontrollersPathfollower * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_CONTROLLERS_TYPE_PATHFOLLOWER, soycontrollersPathfollower);
	_g_object_unref0 (self->priv->_path);
	_g_object_unref0 (self->priv->_iter_path);
	_g_object_unref0 (self->controlled);
	_vala_clear_GRecMutex (&self->path_lock);
	_vala_clear_GMutex (&self->pause_lock);
	G_OBJECT_CLASS (soy_controllers_pathfollower_parent_class)->finalize (obj);
}


GType soy_controllers_pathfollower_get_type (void) {
	static volatile gsize soy_controllers_pathfollower_type_id__volatile = 0;
	if (g_once_init_enter (&soy_controllers_pathfollower_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (soycontrollersPathfollowerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) soy_controllers_pathfollower_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (soycontrollersPathfollower), 0, (GInstanceInitFunc) soy_controllers_pathfollower_instance_init, NULL };
		GType soy_controllers_pathfollower_type_id;
		soy_controllers_pathfollower_type_id = g_type_register_static (SOY_CONTROLLERS_TYPE_VIRTUAL_CONTROLLER, "soycontrollersPathfollower", &g_define_type_info, 0);
		g_once_init_leave (&soy_controllers_pathfollower_type_id__volatile, soy_controllers_pathfollower_type_id);
	}
	return soy_controllers_pathfollower_type_id__volatile;
}


static void _vala_soy_controllers_pathfollower_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	soycontrollersPathfollower * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SOY_CONTROLLERS_TYPE_PATHFOLLOWER, soycontrollersPathfollower);
	switch (property_id) {
		case SOY_CONTROLLERS_PATHFOLLOWER_PATH:
		g_value_set_object (value, soy_controllers_pathfollower_get_path (self));
		break;
		case SOY_CONTROLLERS_PATHFOLLOWER_SPEED:
		g_value_set_float (value, soy_controllers_pathfollower_get_speed (self));
		break;
		case SOY_CONTROLLERS_PATHFOLLOWER_FINISHED:
		g_value_set_boolean (value, soy_controllers_virtual_controller_get_finished ((soycontrollersVirtualController*) self));
		break;
		case SOY_CONTROLLERS_PATHFOLLOWER_PAUSED:
		g_value_set_boolean (value, soy_controllers_pathfollower_get_paused (self));
		break;
		case SOY_CONTROLLERS_PATHFOLLOWER_FUZZINESS:
		g_value_set_float (value, soy_controllers_pathfollower_get_fuzziness (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_soy_controllers_pathfollower_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	soycontrollersPathfollower * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SOY_CONTROLLERS_TYPE_PATHFOLLOWER, soycontrollersPathfollower);
	switch (property_id) {
		case SOY_CONTROLLERS_PATHFOLLOWER_PATH:
		soy_controllers_pathfollower_set_path (self, g_value_get_object (value));
		break;
		case SOY_CONTROLLERS_PATHFOLLOWER_SPEED:
		soy_controllers_pathfollower_set_speed (self, g_value_get_float (value));
		break;
		case SOY_CONTROLLERS_PATHFOLLOWER_PAUSED:
		soy_controllers_pathfollower_set_paused (self, g_value_get_boolean (value));
		break;
		case SOY_CONTROLLERS_PATHFOLLOWER_FUZZINESS:
		soy_controllers_pathfollower_set_fuzziness (self, g_value_get_float (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_clear_GMutex (GMutex * mutex) {
	GMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GMutex))) {
		g_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GMutex));
	}
}


static void _vala_clear_GRecMutex (GRecMutex * mutex) {
	GRecMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRecMutex))) {
		g_rec_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GRecMutex));
	}
}


static void _vala_clear_GRWLock (GRWLock * mutex) {
	GRWLock zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRWLock))) {
		g_rw_lock_clear (mutex);
		memset (mutex, 0, sizeof (GRWLock));
	}
}


static void _vala_clear_GCond (GCond * mutex) {
	GCond zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GCond))) {
		g_cond_clear (mutex);
		memset (mutex, 0, sizeof (GCond));
	}
}



