/* Texture.c generated by valac 0.20.1, the Vala compiler
 * generated from Texture.gs, do not modify */

/*
 *  libsoy - soy.textures.Texture
 *  Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013 Copyleft Games Group
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program; if not, see http://www.gnu.org/licenses
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <GLES/gl.h>
#include <GLES/glext.h>
#include <gee.h>
#include <float.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <gio/gio.h>
#include <librsvg/rsvg.h>


#define SOY_TEXTURES_TYPE_TEXTURE (soy_textures_texture_get_type ())
#define SOY_TEXTURES_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture))
#define SOY_TEXTURES_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTextureClass))
#define SOY_TEXTURES_IS_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_TEXTURES_TYPE_TEXTURE))
#define SOY_TEXTURES_IS_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_TEXTURES_TYPE_TEXTURE))
#define SOY_TEXTURES_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTextureClass))

typedef struct _soytexturesTexture soytexturesTexture;
typedef struct _soytexturesTextureClass soytexturesTextureClass;
typedef struct _soytexturesTexturePrivate soytexturesTexturePrivate;

#define SOY_ATOMS_TYPE_COLOR (soy_atoms_color_get_type ())
#define SOY_ATOMS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_COLOR, soyatomsColor))
#define SOY_ATOMS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_COLOR, soyatomsColorClass))
#define SOY_ATOMS_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_COLOR))
#define SOY_ATOMS_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_COLOR))
#define SOY_ATOMS_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_COLOR, soyatomsColorClass))

typedef struct _soyatomsColor soyatomsColor;
typedef struct _soyatomsColorClass soyatomsColorClass;

#define SOY_ATOMS_TYPE_SIZE (soy_atoms_size_get_type ())
#define SOY_ATOMS_SIZE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_SIZE, soyatomsSize))
#define SOY_ATOMS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_SIZE, soyatomsSizeClass))
#define SOY_ATOMS_IS_SIZE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_SIZE))
#define SOY_ATOMS_IS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_SIZE))
#define SOY_ATOMS_SIZE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_SIZE, soyatomsSizeClass))

typedef struct _soyatomsSize soyatomsSize;
typedef struct _soyatomsSizeClass soyatomsSizeClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))

typedef enum  {
	IO_ERROR_FILE_NOT_FOUND,
	IO_ERROR_READ_ERROR
} IOError;
#define IO_ERROR io_error_quark ()
typedef enum  {
	MEMORY_ERROR_OUT_OF_MEMORY
} MemoryError;
#define MEMORY_ERROR memory_error_quark ()
struct _soytexturesTexture {
	GObject parent_instance;
	soytexturesTexturePrivate * priv;
	gboolean translucent;
	guchar* texels;
	guchar* mipmaps;
	gboolean updated;
};

struct _soytexturesTextureClass {
	GObjectClass parent_class;
	void (*enable) (soytexturesTexture* self);
	void (*disable) (soytexturesTexture* self);
};

struct _soytexturesTexturePrivate {
	GLuint _textureID;
	GeeHashMap* _texel_objs;
	gint _isAnimated;
	GLfloat _scaleX;
	GLfloat _scaleY;
	GLfloat _translateX;
	GLfloat _translateY;
	GMutex _mutex;
	GLfloat* _animate;
	gint _animate_length1;
	gint __animate_size_;
	gfloat _aspect;
	gint _chans;
	GLsizei _width;
	GLsizei _height;
	soyatomsSize* _size_obj;
	gboolean _smooth;
	gboolean _wrap;
};


static gpointer soy_textures_texture_parent_class = NULL;
static GLenum* soy_textures_texture__formats;
static gint soy_textures_texture__formats_length1;
static GLenum* soy_textures_texture__formats = NULL;
static gint soy_textures_texture__formats_length1 = 0;
static gint _soy_textures_texture__formats_size_ = 0;

GQuark io_error_quark (void);
GQuark memory_error_quark (void);
GType soy_textures_texture_get_type (void) G_GNUC_CONST;
GType soy_atoms_color_get_type (void) G_GNUC_CONST;
GType soy_atoms_size_get_type (void) G_GNUC_CONST;
#define SOY_TEXTURES_TEXTURE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexturePrivate))
enum  {
	SOY_TEXTURES_TEXTURE_DUMMY_PROPERTY,
	SOY_TEXTURES_TEXTURE_ASPECT,
	SOY_TEXTURES_TEXTURE_CHANNELS,
	SOY_TEXTURES_TEXTURE_SIZE,
	SOY_TEXTURES_TEXTURE_SMOOTH,
	SOY_TEXTURES_TEXTURE_WRAP
};
soytexturesTexture* soy_textures_texture_new (void);
soytexturesTexture* soy_textures_texture_construct (GType object_type);
soytexturesTexture* soy_textures_texture_new_pattern (const gchar* name, soyatomsColor** colorArray, int colorArray_length1, gint xScale, gint yScale, gint size);
soytexturesTexture* soy_textures_texture_construct_pattern (GType object_type, const gchar* name, soyatomsColor** colorArray, int colorArray_length1, gint xScale, gint yScale, gint size);
void soy_textures_texture_resize (soytexturesTexture* self, gint c, gint x, gint y);
soyatomsColor* soy_atoms_color_new_named (const gchar* color);
soyatomsColor* soy_atoms_color_construct_named (GType object_type, const gchar* color);
guchar soy_atoms_color_get_alpha (soyatomsColor* self);
void soy_textures_texture_set_smooth (soytexturesTexture* self, gboolean value);
void soy_textures_texture_set_wrap (soytexturesTexture* self, gboolean value);
void soy_textures_texture_set (soytexturesTexture* self, gint index, GObject* value);
void soy_textures_texture_generate_lerped_colors (guchar* dst, gfloat* xs, gfloat c1, gfloat c2, gfloat divisor, gint n);
guchar soy_atoms_color_get_red (soyatomsColor* self);
guchar soy_atoms_color_get_green (soyatomsColor* self);
guchar soy_atoms_color_get_blue (soyatomsColor* self);
soyatomsColor* soy_atoms_color_new (guchar red, guchar green, guchar blue, guchar alpha);
soyatomsColor* soy_atoms_color_construct (GType object_type, guchar red, guchar green, guchar blue, guchar alpha);
void soy_textures_texture_generate_palette_color (guchar* dst, gfloat* xs, gfloat c1, gfloat c2, gfloat c3, gfloat c4, gfloat y, gfloat divisor, gfloat bound, gint n);
soytexturesTexture* soy_textures_texture_new_from_png (const gchar* filename, GError** error);
soytexturesTexture* soy_textures_texture_construct_from_png (GType object_type, const gchar* filename, GError** error);
static void _soy_textures_texture_copySurface (soytexturesTexture* self, cairo_surface_t* surface);
soytexturesTexture* soy_textures_texture_new_from_svg (const gchar* filename, GError** error);
soytexturesTexture* soy_textures_texture_construct_from_svg (GType object_type, const gchar* filename, GError** error);
soytexturesTexture* soy_textures_texture_new_from_svg_string (guint8* data, int data_length1, GError** error);
soytexturesTexture* soy_textures_texture_construct_from_svg_string (GType object_type, guint8* data, int data_length1, GError** error);
static void _soy_textures_texture_size_set (soytexturesTexture* self, soyatomsSize* size);
gfloat soy_atoms_size_get_width (soyatomsSize* self);
gfloat soy_atoms_size_get_height (soyatomsSize* self);
static void _soy_textures_texture_size_weak (soytexturesTexture* self, GObject* size);
soyatomsColor* soy_textures_texture_get (soytexturesTexture* self, gint index);
static void _soy_textures_texture_texel_set (soytexturesTexture* self, soyatomsColor* color);
static void __soy_textures_texture_texel_set_soy_atoms_color_on_set (soyatomsColor* _sender, soyatomsColor* color, gpointer self);
static void _soy_textures_texture_texel_weak (soytexturesTexture* self, GObject* color);
static void __soy_textures_texture_texel_weak_gweak_notify (gpointer self, GObject* object);
guchar soy_atoms_color_get_luma (soyatomsColor* self);
gint soy_textures_texture_squareup (gint _v);
void soy_textures_texture_surface2rgba (guchar* dst, gint dst_stride, guchar* src, gint src_stride, gint n, gint m);
void soy_textures_texture_update (soytexturesTexture* self, GLenum target);
void soy_textures_texture_bind (soytexturesTexture* self, GLenum target);
void soy_textures_texture_enable (soytexturesTexture* self);
static void soy_textures_texture_real_enable (soytexturesTexture* self);
void soy_textures_texture_disable (soytexturesTexture* self);
static void soy_textures_texture_real_disable (soytexturesTexture* self);
void soy_textures_texture_load (soytexturesTexture* self, void* _vdata, gint _size);
static guchar* _vala_array_dup11 (guchar* self, int length);
GLfloat* soy_textures_texture_get_animate (soytexturesTexture* self, int* result_length1);
gfloat soy_textures_texture_get_aspect (soytexturesTexture* self);
gint soy_textures_texture_get_channels (soytexturesTexture* self);
void soy_textures_texture_set_channels (soytexturesTexture* self, gint value);
soyatomsSize* soy_textures_texture_get_size (soytexturesTexture* self);
soyatomsSize* soy_atoms_size_new (gfloat width, gfloat height, gfloat depth);
soyatomsSize* soy_atoms_size_construct (GType object_type, gfloat width, gfloat height, gfloat depth);
static void __soy_textures_texture_size_set_soy_atoms_size_on_set (soyatomsSize* _sender, soyatomsSize* size, gpointer self);
static void __soy_textures_texture_size_weak_gweak_notify (gpointer self, GObject* object);
void soy_textures_texture_set_size (soytexturesTexture* self, soyatomsSize* value);
gboolean soy_textures_texture_get_smooth (soytexturesTexture* self);
gboolean soy_textures_texture_get_wrap (soytexturesTexture* self);
static GObject * soy_textures_texture_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void soy_textures_texture_finalize (GObject* obj);
static void _vala_soy_textures_texture_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_soy_textures_texture_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_clear_GMutex (GMutex * mutex);
static void _vala_clear_GRecMutex (GRecMutex * mutex);
static void _vala_clear_GRWLock (GRWLock * mutex);
static void _vala_clear_GCond (GCond * mutex);


GQuark io_error_quark (void) {
	return g_quark_from_static_string ("io_error-quark");
}


GQuark memory_error_quark (void) {
	return g_quark_from_static_string ("memory_error-quark");
}


soytexturesTexture* soy_textures_texture_construct (GType object_type) {
	soytexturesTexture * self = NULL;
	self = (soytexturesTexture*) g_object_new (object_type, NULL);
	self->priv->_chans = 3;
	return self;
}


soytexturesTexture* soy_textures_texture_new (void) {
	return soy_textures_texture_construct (SOY_TEXTURES_TYPE_TEXTURE);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


soytexturesTexture* soy_textures_texture_construct_pattern (GType object_type, const gchar* name, soyatomsColor** colorArray, int colorArray_length1, gint xScale, gint yScale, gint size) {
	soytexturesTexture * self = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
	static GQuark _tmp2_label0 = 0;
	static GQuark _tmp2_label1 = 0;
	static GQuark _tmp2_label2 = 0;
	g_return_val_if_fail (name != NULL, NULL);
	self = (soytexturesTexture*) g_object_new (object_type, NULL);
	_tmp0_ = name;
	_tmp1_ = _tmp0_;
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
	if (_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("checkered")))) {
		switch (0) {
			default:
			{
				{
					gboolean _tmp4_ = FALSE;
					gint _tmp5_;
					gboolean _tmp7_;
					gint _tmp8_;
					gdouble _tmp9_ = 0.0;
					gint h;
					gint _tmp10_;
					gdouble _tmp11_ = 0.0;
					gint w;
					gint _tmp12_ = 0;
					gint _tmp13_;
					gint _tmp22_;
					gint side;
					gint _tmp23_;
					gint _tmp24_;
					soyatomsColor* a = NULL;
					soyatomsColor* b = NULL;
					soyatomsColor** _tmp25_;
					gint _tmp25__length1;
					gboolean _tmp46_ = FALSE;
					soyatomsColor* _tmp47_;
					guchar _tmp48_;
					guchar _tmp49_;
					gboolean _tmp53_;
					gint i = 0;
					gint j = 0;
					gint k = 0;
					gboolean _tmp54_ = FALSE;
					gint _tmp55_;
					gint _tmp56_;
					gboolean _tmp59_;
					gint l = 0;
					gint m = 0;
					gint n = 0;
					gint o = 0;
					gint p = 0;
					gint _tmp83_;
					gint _tmp84_;
					gint _tmp85_;
					gint _tmp86_;
					gboolean check = FALSE;
					_tmp5_ = xScale;
					if (_tmp5_ < 1) {
						_tmp4_ = TRUE;
					} else {
						gint _tmp6_;
						_tmp6_ = yScale;
						_tmp4_ = _tmp6_ < 1;
					}
					_tmp7_ = _tmp4_;
					if (_tmp7_) {
						return self;
					}
					_tmp8_ = yScale;
					_tmp9_ = pow ((gdouble) 2, (gdouble) _tmp8_);
					h = (gint) _tmp9_;
					_tmp10_ = xScale;
					_tmp11_ = pow ((gdouble) 2, (gdouble) _tmp10_);
					w = (gint) _tmp11_;
					_tmp13_ = size;
					if (_tmp13_ == 0) {
						gint _tmp14_ = 0;
						gint _tmp15_;
						gint _tmp16_;
						gint _tmp19_;
						_tmp15_ = xScale;
						_tmp16_ = yScale;
						if (_tmp15_ > _tmp16_) {
							gint _tmp17_;
							_tmp17_ = w;
							_tmp14_ = _tmp17_;
						} else {
							gint _tmp18_;
							_tmp18_ = h;
							_tmp14_ = _tmp18_;
						}
						_tmp19_ = _tmp14_;
						_tmp12_ = _tmp19_;
					} else {
						gint _tmp20_;
						gdouble _tmp21_ = 0.0;
						_tmp20_ = size;
						_tmp21_ = pow ((gdouble) 2, (gdouble) _tmp20_);
						_tmp12_ = (gint) _tmp21_;
					}
					_tmp22_ = _tmp12_;
					side = _tmp22_;
					_tmp23_ = side;
					_tmp24_ = side;
					soy_textures_texture_resize (self, 4, _tmp23_, _tmp24_);
					_tmp25_ = colorArray;
					_tmp25__length1 = colorArray_length1;
					if (_tmp25__length1 == 0) {
						soyatomsColor* _tmp26_;
						soyatomsColor* _tmp27_;
						_tmp26_ = soy_atoms_color_new_named ("white");
						_g_object_unref0 (a);
						a = _tmp26_;
						_tmp27_ = soy_atoms_color_new_named ("black");
						_g_object_unref0 (b);
						b = _tmp27_;
					} else {
						soyatomsColor** _tmp28_;
						gint _tmp28__length1;
						_tmp28_ = colorArray;
						_tmp28__length1 = colorArray_length1;
						if (_tmp28__length1 == 1) {
							soyatomsColor** _tmp29_;
							gint _tmp29__length1;
							soyatomsColor* _tmp30_;
							soyatomsColor* _tmp31_;
							soyatomsColor* _tmp32_;
							_tmp29_ = colorArray;
							_tmp29__length1 = colorArray_length1;
							_tmp30_ = _tmp29_[0];
							_tmp31_ = _g_object_ref0 (_tmp30_);
							_g_object_unref0 (a);
							a = _tmp31_;
							_tmp32_ = soy_atoms_color_new_named ("black");
							_g_object_unref0 (b);
							b = _tmp32_;
						} else {
							soyatomsColor** _tmp33_;
							gint _tmp33__length1;
							_tmp33_ = colorArray;
							_tmp33__length1 = colorArray_length1;
							if (_tmp33__length1 == 2) {
								soyatomsColor** _tmp34_;
								gint _tmp34__length1;
								soyatomsColor* _tmp35_;
								soyatomsColor* _tmp36_;
								soyatomsColor** _tmp37_;
								gint _tmp37__length1;
								soyatomsColor* _tmp38_;
								soyatomsColor* _tmp39_;
								_tmp34_ = colorArray;
								_tmp34__length1 = colorArray_length1;
								_tmp35_ = _tmp34_[0];
								_tmp36_ = _g_object_ref0 (_tmp35_);
								_g_object_unref0 (a);
								a = _tmp36_;
								_tmp37_ = colorArray;
								_tmp37__length1 = colorArray_length1;
								_tmp38_ = _tmp37_[1];
								_tmp39_ = _g_object_ref0 (_tmp38_);
								_g_object_unref0 (b);
								b = _tmp39_;
							} else {
								soyatomsColor** _tmp40_;
								gint _tmp40__length1;
								soyatomsColor* _tmp41_;
								soyatomsColor* _tmp42_;
								soyatomsColor** _tmp43_;
								gint _tmp43__length1;
								soyatomsColor* _tmp44_;
								soyatomsColor* _tmp45_;
								_tmp40_ = colorArray;
								_tmp40__length1 = colorArray_length1;
								_tmp41_ = _tmp40_[0];
								_tmp42_ = _g_object_ref0 (_tmp41_);
								_g_object_unref0 (a);
								a = _tmp42_;
								_tmp43_ = colorArray;
								_tmp43__length1 = colorArray_length1;
								_tmp44_ = _tmp43_[1];
								_tmp45_ = _g_object_ref0 (_tmp44_);
								_g_object_unref0 (b);
								b = _tmp45_;
								g_print ("The color array is too long.\n");
							}
						}
					}
					_tmp47_ = a;
					_tmp48_ = soy_atoms_color_get_alpha (_tmp47_);
					_tmp49_ = _tmp48_;
					if (((gint) _tmp49_) != 255) {
						_tmp46_ = TRUE;
					} else {
						soyatomsColor* _tmp50_;
						guchar _tmp51_;
						guchar _tmp52_;
						_tmp50_ = b;
						_tmp51_ = soy_atoms_color_get_alpha (_tmp50_);
						_tmp52_ = _tmp51_;
						_tmp46_ = ((gint) _tmp52_) != 255;
					}
					_tmp53_ = _tmp46_;
					if (_tmp53_) {
						self->translucent = TRUE;
					}
					soy_textures_texture_set_smooth (self, FALSE);
					soy_textures_texture_set_wrap (self, FALSE);
					self->updated = TRUE;
					k = 0;
					_tmp55_ = w;
					_tmp56_ = side;
					if (_tmp55_ == _tmp56_) {
						gint _tmp57_;
						gint _tmp58_;
						_tmp57_ = w;
						_tmp58_ = h;
						_tmp54_ = _tmp57_ == _tmp58_;
					} else {
						_tmp54_ = FALSE;
					}
					_tmp59_ = _tmp54_;
					if (_tmp59_) {
						{
							gboolean _tmp60_;
							i = 0;
							_tmp60_ = TRUE;
							while (TRUE) {
								gboolean _tmp61_;
								gint _tmp63_;
								_tmp61_ = _tmp60_;
								if (!_tmp61_) {
									gint _tmp62_;
									_tmp62_ = i;
									i = _tmp62_ + 1;
								}
								_tmp60_ = FALSE;
								_tmp63_ = h;
								if (!(i <= (_tmp63_ - 1))) {
									break;
								}
								{
									gboolean _tmp64_;
									j = 0;
									_tmp64_ = TRUE;
									while (TRUE) {
										gboolean _tmp65_;
										gint _tmp67_;
										gboolean _tmp68_ = FALSE;
										gboolean _tmp69_ = FALSE;
										gint _tmp70_;
										gboolean _tmp72_;
										gboolean _tmp77_;
										gint _tmp82_;
										_tmp65_ = _tmp64_;
										if (!_tmp65_) {
											gint _tmp66_;
											_tmp66_ = j;
											j = _tmp66_ + 1;
										}
										_tmp64_ = FALSE;
										_tmp67_ = w;
										if (!(j <= (_tmp67_ - 1))) {
											break;
										}
										_tmp70_ = i;
										if ((_tmp70_ % 2) == 0) {
											gint _tmp71_;
											_tmp71_ = j;
											_tmp69_ = (_tmp71_ % 2) == 0;
										} else {
											_tmp69_ = FALSE;
										}
										_tmp72_ = _tmp69_;
										if (_tmp72_) {
											_tmp68_ = TRUE;
										} else {
											gboolean _tmp73_ = FALSE;
											gint _tmp74_;
											gboolean _tmp76_;
											_tmp74_ = i;
											if ((_tmp74_ % 2) == 1) {
												gint _tmp75_;
												_tmp75_ = j;
												_tmp73_ = (_tmp75_ % 2) == 1;
											} else {
												_tmp73_ = FALSE;
											}
											_tmp76_ = _tmp73_;
											_tmp68_ = _tmp76_;
										}
										_tmp77_ = _tmp68_;
										if (_tmp77_) {
											gint _tmp78_;
											soyatomsColor* _tmp79_;
											_tmp78_ = k;
											_tmp79_ = a;
											soy_textures_texture_set (self, _tmp78_, (GObject*) _tmp79_);
										} else {
											gint _tmp80_;
											soyatomsColor* _tmp81_;
											_tmp80_ = k;
											_tmp81_ = b;
											soy_textures_texture_set (self, _tmp80_, (GObject*) _tmp81_);
										}
										_tmp82_ = k;
										k = _tmp82_ + 1;
									}
								}
							}
						}
						_g_object_unref0 (b);
						_g_object_unref0 (a);
						return self;
					}
					_tmp83_ = side;
					_tmp84_ = h;
					l = (_tmp83_ / _tmp84_) - 1;
					_tmp85_ = side;
					_tmp86_ = w;
					m = (_tmp85_ / _tmp86_) - 1;
					{
						gboolean _tmp87_;
						i = 0;
						_tmp87_ = TRUE;
						while (TRUE) {
							gboolean _tmp88_;
							gint _tmp90_;
							_tmp88_ = _tmp87_;
							if (!_tmp88_) {
								gint _tmp89_;
								_tmp89_ = i;
								i = _tmp89_ + 1;
							}
							_tmp87_ = FALSE;
							_tmp90_ = h;
							if (!(i <= (_tmp90_ - 1))) {
								break;
							}
							{
								gboolean _tmp91_;
								j = 0;
								_tmp91_ = TRUE;
								while (TRUE) {
									gboolean _tmp92_;
									gint _tmp94_;
									gboolean _tmp95_ = FALSE;
									gboolean _tmp96_ = FALSE;
									gint _tmp97_;
									gboolean _tmp99_;
									gboolean _tmp104_;
									gint _tmp105_;
									gint _tmp106_;
									gint _tmp107_;
									gint _tmp108_;
									gint _tmp109_;
									_tmp92_ = _tmp91_;
									if (!_tmp92_) {
										gint _tmp93_;
										_tmp93_ = j;
										j = _tmp93_ + 1;
									}
									_tmp91_ = FALSE;
									_tmp94_ = w;
									if (!(j <= (_tmp94_ - 1))) {
										break;
									}
									_tmp97_ = i;
									if ((_tmp97_ % 2) == 0) {
										gint _tmp98_;
										_tmp98_ = j;
										_tmp96_ = (_tmp98_ % 2) == 0;
									} else {
										_tmp96_ = FALSE;
									}
									_tmp99_ = _tmp96_;
									if (_tmp99_) {
										_tmp95_ = TRUE;
									} else {
										gboolean _tmp100_ = FALSE;
										gint _tmp101_;
										gboolean _tmp103_;
										_tmp101_ = i;
										if ((_tmp101_ % 2) == 1) {
											gint _tmp102_;
											_tmp102_ = j;
											_tmp100_ = (_tmp102_ % 2) == 1;
										} else {
											_tmp100_ = FALSE;
										}
										_tmp103_ = _tmp100_;
										_tmp95_ = _tmp103_;
									}
									_tmp104_ = _tmp95_;
									check = _tmp104_;
									_tmp105_ = i;
									_tmp106_ = side;
									_tmp107_ = l;
									_tmp108_ = j;
									_tmp109_ = m;
									k = ((_tmp105_ * _tmp106_) * (_tmp107_ + 1)) + (_tmp108_ * (_tmp109_ + 1));
									{
										gboolean _tmp110_;
										n = 0;
										_tmp110_ = TRUE;
										while (TRUE) {
											gboolean _tmp111_;
											gint _tmp113_;
											gint _tmp114_;
											gint _tmp125_;
											gint _tmp126_;
											_tmp111_ = _tmp110_;
											if (!_tmp111_) {
												gint _tmp112_;
												_tmp112_ = n;
												n = _tmp112_ + 1;
											}
											_tmp110_ = FALSE;
											_tmp113_ = l;
											if (!(n <= _tmp113_)) {
												break;
											}
											_tmp114_ = k;
											p = _tmp114_;
											{
												gboolean _tmp115_;
												o = 0;
												_tmp115_ = TRUE;
												while (TRUE) {
													gboolean _tmp116_;
													gint _tmp118_;
													soyatomsColor* _tmp119_ = NULL;
													gboolean _tmp120_;
													gint _tmp123_;
													soyatomsColor* _tmp124_;
													_tmp116_ = _tmp115_;
													if (!_tmp116_) {
														gint _tmp117_;
														_tmp117_ = o;
														o = _tmp117_ + 1;
													}
													_tmp115_ = FALSE;
													_tmp118_ = m;
													if (!(o <= _tmp118_)) {
														break;
													}
													_tmp120_ = check;
													if (_tmp120_) {
														soyatomsColor* _tmp121_;
														_tmp121_ = a;
														_tmp119_ = _tmp121_;
													} else {
														soyatomsColor* _tmp122_;
														_tmp122_ = b;
														_tmp119_ = _tmp122_;
													}
													_tmp123_ = k;
													k = _tmp123_ + 1;
													_tmp124_ = _tmp119_;
													soy_textures_texture_set (self, _tmp123_, (GObject*) _tmp124_);
												}
											}
											_tmp125_ = side;
											_tmp126_ = p;
											k = _tmp125_ + _tmp126_;
										}
									}
								}
							}
						}
					}
					_g_object_unref0 (b);
					_g_object_unref0 (a);
				}
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("palette")))) {
		switch (0) {
			default:
			{
				{
					gboolean _tmp127_ = FALSE;
					soyatomsColor** _tmp128_;
					gint _tmp128__length1;
					gboolean _tmp130_;
					gboolean _tmp131_ = FALSE;
					soyatomsColor** _tmp132_;
					gint _tmp132__length1;
					soyatomsColor* _tmp133_;
					guchar _tmp134_;
					guchar _tmp135_;
					gboolean _tmp140_;
					soyatomsColor** _tmp141_;
					gint _tmp141__length1;
					_tmp128_ = colorArray;
					_tmp128__length1 = colorArray_length1;
					if (_tmp128__length1 != 2) {
						soyatomsColor** _tmp129_;
						gint _tmp129__length1;
						_tmp129_ = colorArray;
						_tmp129__length1 = colorArray_length1;
						_tmp127_ = _tmp129__length1 != 4;
					} else {
						_tmp127_ = FALSE;
					}
					_tmp130_ = _tmp127_;
					if (_tmp130_) {
						return self;
					}
					_tmp132_ = colorArray;
					_tmp132__length1 = colorArray_length1;
					_tmp133_ = _tmp132_[0];
					_tmp134_ = soy_atoms_color_get_alpha (_tmp133_);
					_tmp135_ = _tmp134_;
					if (((gint) _tmp135_) != 255) {
						_tmp131_ = TRUE;
					} else {
						soyatomsColor** _tmp136_;
						gint _tmp136__length1;
						soyatomsColor* _tmp137_;
						guchar _tmp138_;
						guchar _tmp139_;
						_tmp136_ = colorArray;
						_tmp136__length1 = colorArray_length1;
						_tmp137_ = _tmp136_[1];
						_tmp138_ = soy_atoms_color_get_alpha (_tmp137_);
						_tmp139_ = _tmp138_;
						_tmp131_ = ((gint) _tmp139_) != 255;
					}
					_tmp140_ = _tmp131_;
					if (_tmp140_) {
						self->translucent = TRUE;
					}
					_tmp141_ = colorArray;
					_tmp141__length1 = colorArray_length1;
					if (_tmp141__length1 == 2) {
						void* _tmp142_ = NULL;
						gfloat* xs;
						void* _tmp150_ = NULL;
						guchar* reds;
						void* _tmp151_ = NULL;
						guchar* greens;
						void* _tmp152_ = NULL;
						guchar* blues;
						void* _tmp153_ = NULL;
						guchar* alphas;
						guchar* _tmp154_;
						gfloat* _tmp155_;
						soyatomsColor** _tmp156_;
						gint _tmp156__length1;
						soyatomsColor* _tmp157_;
						guchar _tmp158_;
						guchar _tmp159_;
						soyatomsColor** _tmp160_;
						gint _tmp160__length1;
						soyatomsColor* _tmp161_;
						guchar _tmp162_;
						guchar _tmp163_;
						guchar* _tmp164_;
						gfloat* _tmp165_;
						soyatomsColor** _tmp166_;
						gint _tmp166__length1;
						soyatomsColor* _tmp167_;
						guchar _tmp168_;
						guchar _tmp169_;
						soyatomsColor** _tmp170_;
						gint _tmp170__length1;
						soyatomsColor* _tmp171_;
						guchar _tmp172_;
						guchar _tmp173_;
						guchar* _tmp174_;
						gfloat* _tmp175_;
						soyatomsColor** _tmp176_;
						gint _tmp176__length1;
						soyatomsColor* _tmp177_;
						guchar _tmp178_;
						guchar _tmp179_;
						soyatomsColor** _tmp180_;
						gint _tmp180__length1;
						soyatomsColor* _tmp181_;
						guchar _tmp182_;
						guchar _tmp183_;
						guchar* _tmp184_;
						gfloat* _tmp185_;
						soyatomsColor** _tmp186_;
						gint _tmp186__length1;
						soyatomsColor* _tmp187_;
						guchar _tmp188_;
						guchar _tmp189_;
						soyatomsColor** _tmp190_;
						gint _tmp190__length1;
						soyatomsColor* _tmp191_;
						guchar _tmp192_;
						guchar _tmp193_;
						guchar* _tmp212_;
						guchar* _tmp213_;
						guchar* _tmp214_;
						guchar* _tmp215_;
						gfloat* _tmp216_;
						soy_textures_texture_resize (self, 4, 256, 1);
						_tmp142_ = g_malloc ((gsize) (sizeof (gfloat) * 256));
						xs = _tmp142_;
						{
							gint i;
							i = 1;
							{
								gboolean _tmp143_;
								_tmp143_ = TRUE;
								while (TRUE) {
									gboolean _tmp144_;
									gfloat* _tmp146_;
									gint _tmp147_;
									gint _tmp148_;
									gfloat _tmp149_;
									_tmp144_ = _tmp143_;
									if (!_tmp144_) {
										gint _tmp145_;
										_tmp145_ = i;
										i = _tmp145_ + 1;
									}
									_tmp143_ = FALSE;
									if (!(i <= 256)) {
										break;
									}
									_tmp146_ = xs;
									_tmp147_ = i;
									_tmp148_ = i;
									_tmp146_[_tmp147_ - 1] = (gfloat) _tmp148_;
									_tmp149_ = _tmp146_[_tmp147_ - 1];
								}
							}
						}
						_tmp150_ = g_malloc ((gsize) 256);
						reds = _tmp150_;
						_tmp151_ = g_malloc ((gsize) 256);
						greens = _tmp151_;
						_tmp152_ = g_malloc ((gsize) 256);
						blues = _tmp152_;
						_tmp153_ = g_malloc ((gsize) 256);
						alphas = _tmp153_;
						_tmp154_ = reds;
						_tmp155_ = xs;
						_tmp156_ = colorArray;
						_tmp156__length1 = colorArray_length1;
						_tmp157_ = _tmp156_[0];
						_tmp158_ = soy_atoms_color_get_red (_tmp157_);
						_tmp159_ = _tmp158_;
						_tmp160_ = colorArray;
						_tmp160__length1 = colorArray_length1;
						_tmp161_ = _tmp160_[1];
						_tmp162_ = soy_atoms_color_get_red (_tmp161_);
						_tmp163_ = _tmp162_;
						soy_textures_texture_generate_lerped_colors (_tmp154_, _tmp155_, (gfloat) _tmp159_, (gfloat) _tmp163_, (gfloat) 256, 256);
						_tmp164_ = greens;
						_tmp165_ = xs;
						_tmp166_ = colorArray;
						_tmp166__length1 = colorArray_length1;
						_tmp167_ = _tmp166_[0];
						_tmp168_ = soy_atoms_color_get_green (_tmp167_);
						_tmp169_ = _tmp168_;
						_tmp170_ = colorArray;
						_tmp170__length1 = colorArray_length1;
						_tmp171_ = _tmp170_[1];
						_tmp172_ = soy_atoms_color_get_green (_tmp171_);
						_tmp173_ = _tmp172_;
						soy_textures_texture_generate_lerped_colors (_tmp164_, _tmp165_, (gfloat) _tmp169_, (gfloat) _tmp173_, (gfloat) 256, 256);
						_tmp174_ = blues;
						_tmp175_ = xs;
						_tmp176_ = colorArray;
						_tmp176__length1 = colorArray_length1;
						_tmp177_ = _tmp176_[0];
						_tmp178_ = soy_atoms_color_get_blue (_tmp177_);
						_tmp179_ = _tmp178_;
						_tmp180_ = colorArray;
						_tmp180__length1 = colorArray_length1;
						_tmp181_ = _tmp180_[1];
						_tmp182_ = soy_atoms_color_get_blue (_tmp181_);
						_tmp183_ = _tmp182_;
						soy_textures_texture_generate_lerped_colors (_tmp174_, _tmp175_, (gfloat) _tmp179_, (gfloat) _tmp183_, (gfloat) 256, 256);
						_tmp184_ = alphas;
						_tmp185_ = xs;
						_tmp186_ = colorArray;
						_tmp186__length1 = colorArray_length1;
						_tmp187_ = _tmp186_[0];
						_tmp188_ = soy_atoms_color_get_alpha (_tmp187_);
						_tmp189_ = _tmp188_;
						_tmp190_ = colorArray;
						_tmp190__length1 = colorArray_length1;
						_tmp191_ = _tmp190_[1];
						_tmp192_ = soy_atoms_color_get_alpha (_tmp191_);
						_tmp193_ = _tmp192_;
						soy_textures_texture_generate_lerped_colors (_tmp184_, _tmp185_, (gfloat) _tmp189_, (gfloat) _tmp193_, (gfloat) 256, 256);
						{
							gint i;
							i = 0;
							{
								gboolean _tmp194_;
								_tmp194_ = TRUE;
								while (TRUE) {
									gboolean _tmp195_;
									gint _tmp197_;
									guchar* _tmp198_;
									gint _tmp199_;
									guchar _tmp200_;
									guchar* _tmp201_;
									gint _tmp202_;
									guchar _tmp203_;
									guchar* _tmp204_;
									gint _tmp205_;
									guchar _tmp206_;
									guchar* _tmp207_;
									gint _tmp208_;
									guchar _tmp209_;
									soyatomsColor* _tmp210_;
									soyatomsColor* _tmp211_;
									_tmp195_ = _tmp194_;
									if (!_tmp195_) {
										gint _tmp196_;
										_tmp196_ = i;
										i = _tmp196_ + 1;
									}
									_tmp194_ = FALSE;
									if (!(i <= 255)) {
										break;
									}
									_tmp197_ = i;
									_tmp198_ = reds;
									_tmp199_ = i;
									_tmp200_ = _tmp198_[_tmp199_];
									_tmp201_ = greens;
									_tmp202_ = i;
									_tmp203_ = _tmp201_[_tmp202_];
									_tmp204_ = blues;
									_tmp205_ = i;
									_tmp206_ = _tmp204_[_tmp205_];
									_tmp207_ = alphas;
									_tmp208_ = i;
									_tmp209_ = _tmp207_[_tmp208_];
									_tmp210_ = soy_atoms_color_new (_tmp200_, _tmp203_, _tmp206_, _tmp209_);
									_tmp211_ = _tmp210_;
									soy_textures_texture_set (self, _tmp197_, (GObject*) _tmp211_);
									_g_object_unref0 (_tmp211_);
								}
							}
						}
						_tmp212_ = reds;
						g_free (_tmp212_);
						_tmp213_ = greens;
						g_free (_tmp213_);
						_tmp214_ = blues;
						g_free (_tmp214_);
						_tmp215_ = alphas;
						g_free (_tmp215_);
						_tmp216_ = xs;
						g_free (_tmp216_);
						self->priv->_scaleX = (GLfloat) 0.5f;
						self->priv->_scaleY = (GLfloat) 0.5f;
						self->priv->_translateX = (GLfloat) 0.5f;
						self->priv->_translateY = (GLfloat) 0.5f;
						self->priv->_smooth = TRUE;
						self->priv->_wrap = FALSE;
						self->updated = TRUE;
					} else {
						gboolean _tmp217_ = FALSE;
						soyatomsColor** _tmp218_;
						gint _tmp218__length1;
						soyatomsColor* _tmp219_;
						guchar _tmp220_;
						guchar _tmp221_;
						gboolean _tmp226_;
						gint i = 0;
						gint j = 0;
						gint k = 0;
						gfloat y = 0.0F;
						void* _tmp227_ = NULL;
						gfloat* xs;
						void* _tmp235_ = NULL;
						guchar* reds;
						void* _tmp236_ = NULL;
						guchar* blues;
						void* _tmp237_ = NULL;
						guchar* greens;
						void* _tmp238_ = NULL;
						guchar* alphas;
						guchar* _tmp346_;
						guchar* _tmp347_;
						guchar* _tmp348_;
						guchar* _tmp349_;
						gfloat* _tmp350_;
						_tmp218_ = colorArray;
						_tmp218__length1 = colorArray_length1;
						_tmp219_ = _tmp218_[2];
						_tmp220_ = soy_atoms_color_get_alpha (_tmp219_);
						_tmp221_ = _tmp220_;
						if (((gint) _tmp221_) != 255) {
							_tmp217_ = TRUE;
						} else {
							soyatomsColor** _tmp222_;
							gint _tmp222__length1;
							soyatomsColor* _tmp223_;
							guchar _tmp224_;
							guchar _tmp225_;
							_tmp222_ = colorArray;
							_tmp222__length1 = colorArray_length1;
							_tmp223_ = _tmp222_[3];
							_tmp224_ = soy_atoms_color_get_alpha (_tmp223_);
							_tmp225_ = _tmp224_;
							_tmp217_ = ((gint) _tmp225_) != 255;
						}
						_tmp226_ = _tmp217_;
						if (_tmp226_) {
							self->translucent = TRUE;
						}
						soy_textures_texture_resize (self, 4, 64, 64);
						k = 0;
						_tmp227_ = g_malloc ((gsize) (sizeof (gfloat) * 64));
						xs = _tmp227_;
						{
							gboolean _tmp228_;
							i = 1;
							_tmp228_ = TRUE;
							while (TRUE) {
								gboolean _tmp229_;
								gfloat* _tmp231_;
								gint _tmp232_;
								gint _tmp233_;
								gfloat _tmp234_;
								_tmp229_ = _tmp228_;
								if (!_tmp229_) {
									gint _tmp230_;
									_tmp230_ = i;
									i = _tmp230_ + 1;
								}
								_tmp228_ = FALSE;
								if (!(i <= 64)) {
									break;
								}
								_tmp231_ = xs;
								_tmp232_ = i;
								_tmp233_ = i;
								_tmp231_[_tmp232_ - 1] = (gfloat) _tmp233_;
								_tmp234_ = _tmp231_[_tmp232_ - 1];
							}
						}
						_tmp235_ = g_malloc ((gsize) (64 * 64));
						reds = _tmp235_;
						_tmp236_ = g_malloc ((gsize) (64 * 64));
						blues = _tmp236_;
						_tmp237_ = g_malloc ((gsize) (64 * 64));
						greens = _tmp237_;
						_tmp238_ = g_malloc ((gsize) (64 * 64));
						alphas = _tmp238_;
						{
							gboolean _tmp239_;
							i = 0;
							_tmp239_ = TRUE;
							while (TRUE) {
								gboolean _tmp240_;
								gint _tmp242_;
								gint offset;
								gint _tmp243_;
								guchar* _tmp244_;
								gint _tmp245_;
								gfloat* _tmp246_;
								soyatomsColor** _tmp247_;
								gint _tmp247__length1;
								soyatomsColor* _tmp248_;
								guchar _tmp249_;
								guchar _tmp250_;
								soyatomsColor** _tmp251_;
								gint _tmp251__length1;
								soyatomsColor* _tmp252_;
								guchar _tmp253_;
								guchar _tmp254_;
								soyatomsColor** _tmp255_;
								gint _tmp255__length1;
								soyatomsColor* _tmp256_;
								guchar _tmp257_;
								guchar _tmp258_;
								soyatomsColor** _tmp259_;
								gint _tmp259__length1;
								soyatomsColor* _tmp260_;
								guchar _tmp261_;
								guchar _tmp262_;
								gfloat _tmp263_;
								guchar* _tmp264_;
								gint _tmp265_;
								gfloat* _tmp266_;
								soyatomsColor** _tmp267_;
								gint _tmp267__length1;
								soyatomsColor* _tmp268_;
								guchar _tmp269_;
								guchar _tmp270_;
								soyatomsColor** _tmp271_;
								gint _tmp271__length1;
								soyatomsColor* _tmp272_;
								guchar _tmp273_;
								guchar _tmp274_;
								soyatomsColor** _tmp275_;
								gint _tmp275__length1;
								soyatomsColor* _tmp276_;
								guchar _tmp277_;
								guchar _tmp278_;
								soyatomsColor** _tmp279_;
								gint _tmp279__length1;
								soyatomsColor* _tmp280_;
								guchar _tmp281_;
								guchar _tmp282_;
								gfloat _tmp283_;
								guchar* _tmp284_;
								gint _tmp285_;
								gfloat* _tmp286_;
								soyatomsColor** _tmp287_;
								gint _tmp287__length1;
								soyatomsColor* _tmp288_;
								guchar _tmp289_;
								guchar _tmp290_;
								soyatomsColor** _tmp291_;
								gint _tmp291__length1;
								soyatomsColor* _tmp292_;
								guchar _tmp293_;
								guchar _tmp294_;
								soyatomsColor** _tmp295_;
								gint _tmp295__length1;
								soyatomsColor* _tmp296_;
								guchar _tmp297_;
								guchar _tmp298_;
								soyatomsColor** _tmp299_;
								gint _tmp299__length1;
								soyatomsColor* _tmp300_;
								guchar _tmp301_;
								guchar _tmp302_;
								gfloat _tmp303_;
								guchar* _tmp304_;
								gint _tmp305_;
								gfloat* _tmp306_;
								soyatomsColor** _tmp307_;
								gint _tmp307__length1;
								soyatomsColor* _tmp308_;
								guchar _tmp309_;
								guchar _tmp310_;
								soyatomsColor** _tmp311_;
								gint _tmp311__length1;
								soyatomsColor* _tmp312_;
								guchar _tmp313_;
								guchar _tmp314_;
								soyatomsColor** _tmp315_;
								gint _tmp315__length1;
								soyatomsColor* _tmp316_;
								guchar _tmp317_;
								guchar _tmp318_;
								soyatomsColor** _tmp319_;
								gint _tmp319__length1;
								soyatomsColor* _tmp320_;
								guchar _tmp321_;
								guchar _tmp322_;
								gfloat _tmp323_;
								_tmp240_ = _tmp239_;
								if (!_tmp240_) {
									gint _tmp241_;
									_tmp241_ = i;
									i = _tmp241_ + 1;
								}
								_tmp239_ = FALSE;
								if (!(i <= 63)) {
									break;
								}
								_tmp242_ = i;
								offset = 64 * _tmp242_;
								_tmp243_ = i;
								y = _tmp243_ / 64.0f;
								_tmp244_ = reds;
								_tmp245_ = offset;
								_tmp246_ = xs;
								_tmp247_ = colorArray;
								_tmp247__length1 = colorArray_length1;
								_tmp248_ = _tmp247_[0];
								_tmp249_ = soy_atoms_color_get_red (_tmp248_);
								_tmp250_ = _tmp249_;
								_tmp251_ = colorArray;
								_tmp251__length1 = colorArray_length1;
								_tmp252_ = _tmp251_[1];
								_tmp253_ = soy_atoms_color_get_red (_tmp252_);
								_tmp254_ = _tmp253_;
								_tmp255_ = colorArray;
								_tmp255__length1 = colorArray_length1;
								_tmp256_ = _tmp255_[2];
								_tmp257_ = soy_atoms_color_get_red (_tmp256_);
								_tmp258_ = _tmp257_;
								_tmp259_ = colorArray;
								_tmp259__length1 = colorArray_length1;
								_tmp260_ = _tmp259_[3];
								_tmp261_ = soy_atoms_color_get_red (_tmp260_);
								_tmp262_ = _tmp261_;
								_tmp263_ = y;
								soy_textures_texture_generate_palette_color (_tmp244_ + _tmp245_, _tmp246_, (gfloat) _tmp250_, (gfloat) _tmp254_, (gfloat) _tmp258_, (gfloat) _tmp262_, _tmp263_, (gfloat) 64, (gfloat) 1, 64);
								_tmp264_ = greens;
								_tmp265_ = offset;
								_tmp266_ = xs;
								_tmp267_ = colorArray;
								_tmp267__length1 = colorArray_length1;
								_tmp268_ = _tmp267_[0];
								_tmp269_ = soy_atoms_color_get_green (_tmp268_);
								_tmp270_ = _tmp269_;
								_tmp271_ = colorArray;
								_tmp271__length1 = colorArray_length1;
								_tmp272_ = _tmp271_[1];
								_tmp273_ = soy_atoms_color_get_green (_tmp272_);
								_tmp274_ = _tmp273_;
								_tmp275_ = colorArray;
								_tmp275__length1 = colorArray_length1;
								_tmp276_ = _tmp275_[2];
								_tmp277_ = soy_atoms_color_get_green (_tmp276_);
								_tmp278_ = _tmp277_;
								_tmp279_ = colorArray;
								_tmp279__length1 = colorArray_length1;
								_tmp280_ = _tmp279_[3];
								_tmp281_ = soy_atoms_color_get_green (_tmp280_);
								_tmp282_ = _tmp281_;
								_tmp283_ = y;
								soy_textures_texture_generate_palette_color (_tmp264_ + _tmp265_, _tmp266_, (gfloat) _tmp270_, (gfloat) _tmp274_, (gfloat) _tmp278_, (gfloat) _tmp282_, _tmp283_, (gfloat) 64, (gfloat) 1, 64);
								_tmp284_ = blues;
								_tmp285_ = offset;
								_tmp286_ = xs;
								_tmp287_ = colorArray;
								_tmp287__length1 = colorArray_length1;
								_tmp288_ = _tmp287_[0];
								_tmp289_ = soy_atoms_color_get_blue (_tmp288_);
								_tmp290_ = _tmp289_;
								_tmp291_ = colorArray;
								_tmp291__length1 = colorArray_length1;
								_tmp292_ = _tmp291_[1];
								_tmp293_ = soy_atoms_color_get_blue (_tmp292_);
								_tmp294_ = _tmp293_;
								_tmp295_ = colorArray;
								_tmp295__length1 = colorArray_length1;
								_tmp296_ = _tmp295_[2];
								_tmp297_ = soy_atoms_color_get_blue (_tmp296_);
								_tmp298_ = _tmp297_;
								_tmp299_ = colorArray;
								_tmp299__length1 = colorArray_length1;
								_tmp300_ = _tmp299_[3];
								_tmp301_ = soy_atoms_color_get_blue (_tmp300_);
								_tmp302_ = _tmp301_;
								_tmp303_ = y;
								soy_textures_texture_generate_palette_color (_tmp284_ + _tmp285_, _tmp286_, (gfloat) _tmp290_, (gfloat) _tmp294_, (gfloat) _tmp298_, (gfloat) _tmp302_, _tmp303_, (gfloat) 64, (gfloat) 1, 64);
								_tmp304_ = alphas;
								_tmp305_ = offset;
								_tmp306_ = xs;
								_tmp307_ = colorArray;
								_tmp307__length1 = colorArray_length1;
								_tmp308_ = _tmp307_[0];
								_tmp309_ = soy_atoms_color_get_alpha (_tmp308_);
								_tmp310_ = _tmp309_;
								_tmp311_ = colorArray;
								_tmp311__length1 = colorArray_length1;
								_tmp312_ = _tmp311_[1];
								_tmp313_ = soy_atoms_color_get_alpha (_tmp312_);
								_tmp314_ = _tmp313_;
								_tmp315_ = colorArray;
								_tmp315__length1 = colorArray_length1;
								_tmp316_ = _tmp315_[2];
								_tmp317_ = soy_atoms_color_get_alpha (_tmp316_);
								_tmp318_ = _tmp317_;
								_tmp319_ = colorArray;
								_tmp319__length1 = colorArray_length1;
								_tmp320_ = _tmp319_[3];
								_tmp321_ = soy_atoms_color_get_alpha (_tmp320_);
								_tmp322_ = _tmp321_;
								_tmp323_ = y;
								soy_textures_texture_generate_palette_color (_tmp304_ + _tmp305_, _tmp306_, (gfloat) _tmp310_, (gfloat) _tmp314_, (gfloat) _tmp318_, (gfloat) _tmp322_, _tmp323_, (gfloat) 64, (gfloat) 1, 64);
							}
						}
						{
							gboolean _tmp324_;
							i = 0;
							_tmp324_ = TRUE;
							while (TRUE) {
								gboolean _tmp325_;
								_tmp325_ = _tmp324_;
								if (!_tmp325_) {
									gint _tmp326_;
									_tmp326_ = i;
									i = _tmp326_ + 1;
								}
								_tmp324_ = FALSE;
								if (!(i <= 63)) {
									break;
								}
								{
									gboolean _tmp327_;
									j = 0;
									_tmp327_ = TRUE;
									while (TRUE) {
										gboolean _tmp328_;
										gint _tmp330_;
										guchar* _tmp331_;
										gint _tmp332_;
										guchar _tmp333_;
										guchar* _tmp334_;
										gint _tmp335_;
										guchar _tmp336_;
										guchar* _tmp337_;
										gint _tmp338_;
										guchar _tmp339_;
										guchar* _tmp340_;
										gint _tmp341_;
										guchar _tmp342_;
										soyatomsColor* _tmp343_;
										soyatomsColor* _tmp344_;
										gint _tmp345_;
										_tmp328_ = _tmp327_;
										if (!_tmp328_) {
											gint _tmp329_;
											_tmp329_ = j;
											j = _tmp329_ + 1;
										}
										_tmp327_ = FALSE;
										if (!(j <= 63)) {
											break;
										}
										_tmp330_ = k;
										_tmp331_ = reds;
										_tmp332_ = k;
										_tmp333_ = _tmp331_[_tmp332_];
										_tmp334_ = greens;
										_tmp335_ = k;
										_tmp336_ = _tmp334_[_tmp335_];
										_tmp337_ = blues;
										_tmp338_ = k;
										_tmp339_ = _tmp337_[_tmp338_];
										_tmp340_ = alphas;
										_tmp341_ = k;
										_tmp342_ = _tmp340_[_tmp341_];
										_tmp343_ = soy_atoms_color_new (_tmp333_, _tmp336_, _tmp339_, _tmp342_);
										_tmp344_ = _tmp343_;
										soy_textures_texture_set (self, _tmp330_, (GObject*) _tmp344_);
										_g_object_unref0 (_tmp344_);
										_tmp345_ = k;
										k = _tmp345_ + 1;
									}
								}
							}
						}
						_tmp346_ = reds;
						g_free (_tmp346_);
						_tmp347_ = blues;
						g_free (_tmp347_);
						_tmp348_ = greens;
						g_free (_tmp348_);
						_tmp349_ = alphas;
						g_free (_tmp349_);
						_tmp350_ = xs;
						g_free (_tmp350_);
					}
					self->priv->_wrap = FALSE;
					self->priv->_smooth = TRUE;
					self->updated = TRUE;
				}
				break;
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label2) ? _tmp2_label2 : (_tmp2_label2 = g_quark_from_static_string ("rainbow")))) {
		switch (0) {
			default:
			{
				{
					gint i = 0;
					gfloat delta;
					gfloat h = 0.0F;
					gfloat t = 0.0F;
					guchar r = '\0';
					guchar g = '\0';
					guchar b = '\0';
					guchar _tmp351_;
					guchar _tmp352_;
					soy_textures_texture_resize (self, 3, 128, 1);
					delta = 360.0f / 128.0f;
					b = (guchar) 0;
					_tmp351_ = b;
					g = _tmp351_;
					_tmp352_ = g;
					r = _tmp352_;
					{
						gboolean _tmp353_;
						i = 0;
						_tmp353_ = TRUE;
						while (TRUE) {
							gboolean _tmp354_;
							gint _tmp356_;
							gfloat _tmp357_;
							gfloat _tmp358_;
							gfloat _tmp359_;
							gfloat _tmp363_;
							gfloat _tmp368_;
							gfloat _tmp369_;
							gfloat _tmp373_;
							gfloat _tmp378_;
							gfloat _tmp379_;
							gfloat _tmp383_;
							gint _tmp388_;
							guchar _tmp389_;
							guchar _tmp390_;
							guchar _tmp391_;
							soyatomsColor* _tmp392_;
							soyatomsColor* _tmp393_;
							_tmp354_ = _tmp353_;
							if (!_tmp354_) {
								gint _tmp355_;
								_tmp355_ = i;
								i = _tmp355_ + 1;
							}
							_tmp353_ = FALSE;
							if (!(i <= 127)) {
								break;
							}
							_tmp356_ = i;
							_tmp357_ = delta;
							h = (_tmp356_ * _tmp357_) / 360.0f;
							_tmp358_ = h;
							t = _tmp358_ + (1.0f / 3.0f);
							_tmp359_ = t;
							if (_tmp359_ < 0.0f) {
								gfloat _tmp360_;
								_tmp360_ = t;
								t = _tmp360_ + 1.0f;
							} else {
								gfloat _tmp361_;
								_tmp361_ = t;
								if (_tmp361_ > 1.0f) {
									gfloat _tmp362_;
									_tmp362_ = t;
									t = _tmp362_ - 1.0f;
								}
							}
							_tmp363_ = t;
							if (_tmp363_ < (1.0f / 6.0f)) {
								gfloat _tmp364_;
								_tmp364_ = t;
								r = (guchar) ((6.0f * _tmp364_) * 255.0f);
							} else {
								gfloat _tmp365_;
								_tmp365_ = t;
								if (_tmp365_ < 0.5f) {
									r = (guchar) 255;
								} else {
									gfloat _tmp366_;
									_tmp366_ = t;
									if (_tmp366_ < (2.0f / 3.0f)) {
										gfloat _tmp367_;
										_tmp367_ = t;
										r = (guchar) ((((2.0f / 3.0f) - _tmp367_) * 6.0f) * 255.0f);
									}
								}
							}
							_tmp368_ = h;
							t = _tmp368_;
							_tmp369_ = t;
							if (_tmp369_ < 0.0f) {
								gfloat _tmp370_;
								_tmp370_ = t;
								t = _tmp370_ + 1.0f;
							} else {
								gfloat _tmp371_;
								_tmp371_ = t;
								if (_tmp371_ > 1.0f) {
									gfloat _tmp372_;
									_tmp372_ = t;
									t = _tmp372_ - 1.0f;
								}
							}
							_tmp373_ = t;
							if (_tmp373_ < (1.0f / 6.0f)) {
								gfloat _tmp374_;
								_tmp374_ = t;
								g = (guchar) ((6.0f * _tmp374_) * 255.0f);
							} else {
								gfloat _tmp375_;
								_tmp375_ = t;
								if (_tmp375_ < 0.5f) {
									g = (guchar) 255;
								} else {
									gfloat _tmp376_;
									_tmp376_ = t;
									if (_tmp376_ < (2.0f / 3.0f)) {
										gfloat _tmp377_;
										_tmp377_ = t;
										g = (guchar) ((((2.0f / 3.0f) - _tmp377_) * 6) * 255.0f);
									}
								}
							}
							_tmp378_ = h;
							t = _tmp378_ - (1.0f / 3.0f);
							_tmp379_ = t;
							if (_tmp379_ < 0.0f) {
								gfloat _tmp380_;
								_tmp380_ = t;
								t = _tmp380_ + 1.0f;
							} else {
								gfloat _tmp381_;
								_tmp381_ = t;
								if (_tmp381_ > 1.0f) {
									gfloat _tmp382_;
									_tmp382_ = t;
									t = _tmp382_ - 1.0f;
								}
							}
							_tmp383_ = t;
							if (_tmp383_ < (1.0f / 6.0f)) {
								gfloat _tmp384_;
								_tmp384_ = t;
								b = (guchar) ((6.0f * _tmp384_) * 255.0f);
							} else {
								gfloat _tmp385_;
								_tmp385_ = t;
								if (_tmp385_ < 0.5f) {
									b = (guchar) 255;
								} else {
									gfloat _tmp386_;
									_tmp386_ = t;
									if (_tmp386_ < (2.0f / 3.0f)) {
										gfloat _tmp387_;
										_tmp387_ = t;
										b = (guchar) ((((2.0f / 3.0f) - _tmp387_) * 6) * 255.0f);
									}
								}
							}
							_tmp388_ = i;
							_tmp389_ = r;
							_tmp390_ = g;
							_tmp391_ = b;
							_tmp392_ = soy_atoms_color_new (_tmp389_, _tmp390_, _tmp391_, (guchar) 255);
							_tmp393_ = _tmp392_;
							soy_textures_texture_set (self, _tmp388_, (GObject*) _tmp393_);
							_g_object_unref0 (_tmp393_);
						}
					}
				}
				break;
			}
		}
	}
	return self;
}


soytexturesTexture* soy_textures_texture_new_pattern (const gchar* name, soyatomsColor** colorArray, int colorArray_length1, gint xScale, gint yScale, gint size) {
	return soy_textures_texture_construct_pattern (SOY_TEXTURES_TYPE_TEXTURE, name, colorArray, colorArray_length1, xScale, yScale, size);
}


soytexturesTexture* soy_textures_texture_construct_from_png (GType object_type, const gchar* filename, GError** error) {
	soytexturesTexture * self = NULL;
	cairo_surface_t* surface = NULL;
	const gchar* _tmp0_;
	cairo_surface_t* _tmp1_;
	cairo_surface_t* _tmp2_;
	cairo_status_t _tmp3_ = 0;
	cairo_status_t status;
	cairo_status_t _tmp4_;
	cairo_status_t _tmp7_;
	cairo_status_t _tmp9_;
	cairo_status_t _tmp17_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (soytexturesTexture*) g_object_new (object_type, NULL);
	_tmp0_ = filename;
	_tmp1_ = cairo_image_surface_create_from_png (_tmp0_);
	_cairo_surface_destroy0 (surface);
	surface = _tmp1_;
	_tmp2_ = surface;
	_tmp3_ = cairo_surface_status (_tmp2_);
	status = _tmp3_;
	_tmp4_ = status;
	if (_tmp4_ == CAIRO_STATUS_SUCCESS) {
		cairo_surface_t* _tmp5_;
		gint _tmp6_;
		_tmp5_ = surface;
		_soy_textures_texture_copySurface (self, _tmp5_);
		_tmp6_ = self->priv->_chans;
		self->translucent = (_tmp6_ % 2) == 0;
	}
	_tmp7_ = status;
	if (_tmp7_ == CAIRO_STATUS_NO_MEMORY) {
		GError* _tmp8_;
		_tmp8_ = g_error_new_literal (MEMORY_ERROR, MEMORY_ERROR_OUT_OF_MEMORY, "Out of memory");
		_inner_error_ = _tmp8_;
		if ((_inner_error_->domain == IO_ERROR) || (_inner_error_->domain == MEMORY_ERROR)) {
			g_propagate_error (error, _inner_error_);
			_cairo_surface_destroy0 (surface);
			_g_object_unref0 (self);
			return NULL;
		} else {
			_cairo_surface_destroy0 (surface);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp9_ = status;
	if (_tmp9_ == CAIRO_STATUS_FILE_NOT_FOUND) {
		const gchar* _tmp10_;
		gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* _tmp13_;
		gchar* _tmp14_;
		GError* _tmp15_;
		GError* _tmp16_;
		_tmp10_ = filename;
		_tmp11_ = g_strconcat ("No such file: '", _tmp10_, NULL);
		_tmp12_ = _tmp11_;
		_tmp13_ = g_strconcat (_tmp12_, "'", NULL);
		_tmp14_ = _tmp13_;
		_tmp15_ = g_error_new_literal (IO_ERROR, IO_ERROR_FILE_NOT_FOUND, _tmp14_);
		_tmp16_ = _tmp15_;
		_g_free0 (_tmp14_);
		_g_free0 (_tmp12_);
		_inner_error_ = _tmp16_;
		if ((_inner_error_->domain == IO_ERROR) || (_inner_error_->domain == MEMORY_ERROR)) {
			g_propagate_error (error, _inner_error_);
			_cairo_surface_destroy0 (surface);
			_g_object_unref0 (self);
			return NULL;
		} else {
			_cairo_surface_destroy0 (surface);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp17_ = status;
	if (_tmp17_ == CAIRO_STATUS_READ_ERROR) {
		const gchar* _tmp18_;
		gchar* _tmp19_;
		gchar* _tmp20_;
		gchar* _tmp21_;
		gchar* _tmp22_;
		GError* _tmp23_;
		GError* _tmp24_;
		_tmp18_ = filename;
		_tmp19_ = g_strconcat ("Could not read file: '", _tmp18_, NULL);
		_tmp20_ = _tmp19_;
		_tmp21_ = g_strconcat (_tmp20_, "'", NULL);
		_tmp22_ = _tmp21_;
		_tmp23_ = g_error_new_literal (IO_ERROR, IO_ERROR_READ_ERROR, _tmp22_);
		_tmp24_ = _tmp23_;
		_g_free0 (_tmp22_);
		_g_free0 (_tmp20_);
		_inner_error_ = _tmp24_;
		if ((_inner_error_->domain == IO_ERROR) || (_inner_error_->domain == MEMORY_ERROR)) {
			g_propagate_error (error, _inner_error_);
			_cairo_surface_destroy0 (surface);
			_g_object_unref0 (self);
			return NULL;
		} else {
			_cairo_surface_destroy0 (surface);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_cairo_surface_destroy0 (surface);
	return self;
}


soytexturesTexture* soy_textures_texture_new_from_png (const gchar* filename, GError** error) {
	return soy_textures_texture_construct_from_png (SOY_TEXTURES_TYPE_TEXTURE, filename, error);
}


soytexturesTexture* soy_textures_texture_construct_from_svg (GType object_type, const gchar* filename, GError** error) {
	soytexturesTexture * self = NULL;
	const gchar* _tmp0_;
	GFile* _tmp1_ = NULL;
	GFile* _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_;
	cairo_t* context = NULL;
	RsvgHandle* handle = NULL;
	cairo_surface_t* surface = NULL;
	const gchar* _tmp12_;
	RsvgHandle* _tmp13_;
	RsvgHandle* _tmp14_;
	RsvgHandle* _tmp15_;
	gint _tmp16_ = 0;
	gint _tmp17_;
	RsvgHandle* _tmp18_;
	gint _tmp19_ = 0;
	gint _tmp20_;
	cairo_surface_t* _tmp21_;
	cairo_surface_t* _tmp22_;
	cairo_status_t _tmp23_ = 0;
	cairo_status_t status;
	cairo_status_t _tmp24_;
	cairo_status_t _tmp31_;
	cairo_status_t _tmp33_;
	cairo_status_t _tmp41_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (soytexturesTexture*) g_object_new (object_type, NULL);
	_tmp0_ = filename;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_file_query_exists (_tmp2_, NULL);
	_tmp4_ = !_tmp3_;
	_g_object_unref0 (_tmp2_);
	if (_tmp4_) {
		const gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gchar* _tmp9_;
		GError* _tmp10_;
		GError* _tmp11_;
		_tmp5_ = filename;
		_tmp6_ = g_strconcat ("No such file: '", _tmp5_, NULL);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat (_tmp7_, "'", NULL);
		_tmp9_ = _tmp8_;
		_tmp10_ = g_error_new_literal (IO_ERROR, IO_ERROR_FILE_NOT_FOUND, _tmp9_);
		_tmp11_ = _tmp10_;
		_g_free0 (_tmp9_);
		_g_free0 (_tmp7_);
		_inner_error_ = _tmp11_;
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (self);
		return NULL;
	}
	_tmp12_ = filename;
	_tmp13_ = rsvg_handle_new_from_file (_tmp12_, &_inner_error_);
	_tmp14_ = _tmp13_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (handle);
		_cairo_destroy0 (context);
		_g_object_unref0 (self);
		return NULL;
	}
	_g_object_unref0 (handle);
	handle = _tmp14_;
	_tmp15_ = handle;
	g_object_get (_tmp15_, "width", &_tmp16_, NULL);
	_tmp17_ = _tmp16_;
	_tmp18_ = handle;
	g_object_get (_tmp18_, "height", &_tmp19_, NULL);
	_tmp20_ = _tmp19_;
	_tmp21_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, _tmp17_, _tmp20_);
	_cairo_surface_destroy0 (surface);
	surface = _tmp21_;
	_tmp22_ = surface;
	_tmp23_ = cairo_surface_status (_tmp22_);
	status = _tmp23_;
	_tmp24_ = status;
	if (_tmp24_ == CAIRO_STATUS_SUCCESS) {
		cairo_surface_t* _tmp25_;
		cairo_t* _tmp26_;
		RsvgHandle* _tmp27_;
		cairo_t* _tmp28_;
		cairo_surface_t* _tmp29_;
		gint _tmp30_;
		_tmp25_ = surface;
		_tmp26_ = cairo_create (_tmp25_);
		_cairo_destroy0 (context);
		context = _tmp26_;
		_tmp27_ = handle;
		_tmp28_ = context;
		rsvg_handle_render_cairo (_tmp27_, _tmp28_);
		_tmp29_ = surface;
		_soy_textures_texture_copySurface (self, _tmp29_);
		_tmp30_ = self->priv->_chans;
		self->translucent = (_tmp30_ % 2) == 0;
	}
	_tmp31_ = status;
	if (_tmp31_ == CAIRO_STATUS_NO_MEMORY) {
		GError* _tmp32_;
		_tmp32_ = g_error_new_literal (MEMORY_ERROR, MEMORY_ERROR_OUT_OF_MEMORY, "Out of memory");
		_inner_error_ = _tmp32_;
		g_propagate_error (error, _inner_error_);
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (handle);
		_cairo_destroy0 (context);
		_g_object_unref0 (self);
		return NULL;
	}
	_tmp33_ = status;
	if (_tmp33_ == CAIRO_STATUS_FILE_NOT_FOUND) {
		const gchar* _tmp34_;
		gchar* _tmp35_;
		gchar* _tmp36_;
		gchar* _tmp37_;
		gchar* _tmp38_;
		GError* _tmp39_;
		GError* _tmp40_;
		_tmp34_ = filename;
		_tmp35_ = g_strconcat ("No such file: '", _tmp34_, NULL);
		_tmp36_ = _tmp35_;
		_tmp37_ = g_strconcat (_tmp36_, "'", NULL);
		_tmp38_ = _tmp37_;
		_tmp39_ = g_error_new_literal (IO_ERROR, IO_ERROR_FILE_NOT_FOUND, _tmp38_);
		_tmp40_ = _tmp39_;
		_g_free0 (_tmp38_);
		_g_free0 (_tmp36_);
		_inner_error_ = _tmp40_;
		g_propagate_error (error, _inner_error_);
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (handle);
		_cairo_destroy0 (context);
		_g_object_unref0 (self);
		return NULL;
	}
	_tmp41_ = status;
	if (_tmp41_ == CAIRO_STATUS_READ_ERROR) {
		const gchar* _tmp42_;
		gchar* _tmp43_;
		gchar* _tmp44_;
		gchar* _tmp45_;
		gchar* _tmp46_;
		GError* _tmp47_;
		GError* _tmp48_;
		_tmp42_ = filename;
		_tmp43_ = g_strconcat ("Could not read file: '", _tmp42_, NULL);
		_tmp44_ = _tmp43_;
		_tmp45_ = g_strconcat (_tmp44_, "'", NULL);
		_tmp46_ = _tmp45_;
		_tmp47_ = g_error_new_literal (IO_ERROR, IO_ERROR_READ_ERROR, _tmp46_);
		_tmp48_ = _tmp47_;
		_g_free0 (_tmp46_);
		_g_free0 (_tmp44_);
		_inner_error_ = _tmp48_;
		g_propagate_error (error, _inner_error_);
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (handle);
		_cairo_destroy0 (context);
		_g_object_unref0 (self);
		return NULL;
	}
	_cairo_surface_destroy0 (surface);
	_g_object_unref0 (handle);
	_cairo_destroy0 (context);
	return self;
}


soytexturesTexture* soy_textures_texture_new_from_svg (const gchar* filename, GError** error) {
	return soy_textures_texture_construct_from_svg (SOY_TEXTURES_TYPE_TEXTURE, filename, error);
}


soytexturesTexture* soy_textures_texture_construct_from_svg_string (GType object_type, guint8* data, int data_length1, GError** error) {
	soytexturesTexture * self = NULL;
	cairo_t* context = NULL;
	RsvgHandle* handle = NULL;
	cairo_surface_t* surface = NULL;
	guint8* _tmp0_;
	gint _tmp0__length1;
	RsvgHandle* _tmp1_;
	RsvgHandle* _tmp2_;
	RsvgHandle* _tmp3_;
	gint _tmp4_ = 0;
	gint _tmp5_;
	RsvgHandle* _tmp6_;
	gint _tmp7_ = 0;
	gint _tmp8_;
	cairo_surface_t* _tmp9_;
	cairo_surface_t* _tmp10_;
	cairo_status_t _tmp11_ = 0;
	cairo_status_t status;
	cairo_status_t _tmp12_;
	cairo_status_t _tmp19_;
	GError * _inner_error_ = NULL;
	self = (soytexturesTexture*) g_object_new (object_type, NULL);
	_tmp0_ = data;
	_tmp0__length1 = data_length1;
	_tmp1_ = rsvg_handle_new_from_data (_tmp0_, _tmp0__length1, &_inner_error_);
	_tmp2_ = _tmp1_;
	if (_inner_error_ != NULL) {
		g_propagate_error (error, _inner_error_);
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (handle);
		_cairo_destroy0 (context);
		_g_object_unref0 (self);
		return NULL;
	}
	_g_object_unref0 (handle);
	handle = _tmp2_;
	_tmp3_ = handle;
	g_object_get (_tmp3_, "width", &_tmp4_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = handle;
	g_object_get (_tmp6_, "height", &_tmp7_, NULL);
	_tmp8_ = _tmp7_;
	_tmp9_ = cairo_image_surface_create (CAIRO_FORMAT_ARGB32, _tmp5_, _tmp8_);
	_cairo_surface_destroy0 (surface);
	surface = _tmp9_;
	_tmp10_ = surface;
	_tmp11_ = cairo_surface_status (_tmp10_);
	status = _tmp11_;
	_tmp12_ = status;
	if (_tmp12_ == CAIRO_STATUS_SUCCESS) {
		cairo_surface_t* _tmp13_;
		cairo_t* _tmp14_;
		RsvgHandle* _tmp15_;
		cairo_t* _tmp16_;
		cairo_surface_t* _tmp17_;
		gint _tmp18_;
		_tmp13_ = surface;
		_tmp14_ = cairo_create (_tmp13_);
		_cairo_destroy0 (context);
		context = _tmp14_;
		_tmp15_ = handle;
		_tmp16_ = context;
		rsvg_handle_render_cairo (_tmp15_, _tmp16_);
		_tmp17_ = surface;
		_soy_textures_texture_copySurface (self, _tmp17_);
		_tmp18_ = self->priv->_chans;
		self->translucent = (_tmp18_ % 2) == 0;
	}
	_tmp19_ = status;
	if (_tmp19_ == CAIRO_STATUS_NO_MEMORY) {
		GError* _tmp20_;
		_tmp20_ = g_error_new_literal (MEMORY_ERROR, MEMORY_ERROR_OUT_OF_MEMORY, "Out of memory");
		_inner_error_ = _tmp20_;
		g_propagate_error (error, _inner_error_);
		_cairo_surface_destroy0 (surface);
		_g_object_unref0 (handle);
		_cairo_destroy0 (context);
		_g_object_unref0 (self);
		return NULL;
	}
	_cairo_surface_destroy0 (surface);
	_g_object_unref0 (handle);
	_cairo_destroy0 (context);
	return self;
}


soytexturesTexture* soy_textures_texture_new_from_svg_string (guint8* data, int data_length1, GError** error) {
	return soy_textures_texture_construct_from_svg_string (SOY_TEXTURES_TYPE_TEXTURE, data, data_length1, error);
}


static void _soy_textures_texture_size_set (soytexturesTexture* self, soyatomsSize* size) {
	gint _tmp0_;
	soyatomsSize* _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	glong _tmp4_ = 0L;
	soyatomsSize* _tmp5_;
	gfloat _tmp6_;
	gfloat _tmp7_;
	glong _tmp8_ = 0L;
	g_return_if_fail (self != NULL);
	g_return_if_fail (size != NULL);
	_tmp0_ = self->priv->_chans;
	_tmp1_ = size;
	_tmp2_ = soy_atoms_size_get_width (_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = lround ((gdouble) _tmp3_);
	_tmp5_ = size;
	_tmp6_ = soy_atoms_size_get_height (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = lround ((gdouble) _tmp7_);
	soy_textures_texture_resize (self, _tmp0_, (gint) ((GLsizei) _tmp4_), (gint) ((GLsizei) _tmp8_));
}


static void _soy_textures_texture_size_weak (soytexturesTexture* self, GObject* size) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (size != NULL);
	self->priv->_size_obj = NULL;
}


static void __soy_textures_texture_texel_set_soy_atoms_color_on_set (soyatomsColor* _sender, soyatomsColor* color, gpointer self) {
	_soy_textures_texture_texel_set (self, color);
}


static void __soy_textures_texture_texel_weak_gweak_notify (gpointer self, GObject* object) {
	_soy_textures_texture_texel_weak (self, object);
}


soyatomsColor* soy_textures_texture_get (soytexturesTexture* self, gint index) {
	soyatomsColor* result = NULL;
	soyatomsColor* ret;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp5_;
	GeeHashMap* _tmp6_;
	gint _tmp7_;
	gboolean _tmp8_ = FALSE;
	soyatomsColor* _tmp64_;
	soyatomsColor* _tmp65_;
	GeeHashMap* _tmp66_;
	gint _tmp67_;
	soyatomsColor* _tmp68_;
	soyatomsColor* _tmp69_;
	g_return_val_if_fail (self != NULL, NULL);
	ret = NULL;
	_tmp1_ = index;
	if (_tmp1_ < 0) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		GLsizei _tmp3_;
		GLsizei _tmp4_;
		_tmp2_ = index;
		_tmp3_ = self->priv->_width;
		_tmp4_ = self->priv->_height;
		_tmp0_ = _tmp2_ >= ((gint) (_tmp3_ * _tmp4_));
	}
	_tmp5_ = _tmp0_;
	if (_tmp5_) {
		result = NULL;
		_g_object_unref0 (ret);
		return result;
	}
	_tmp6_ = self->priv->_texel_objs;
	_tmp7_ = index;
	_tmp8_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp6_, (gpointer) ((gintptr) _tmp7_));
	if (_tmp8_) {
		GeeHashMap* _tmp9_;
		gint _tmp10_;
		gpointer _tmp11_ = NULL;
		soyatomsColor* _tmp12_;
		_tmp9_ = self->priv->_texel_objs;
		_tmp10_ = index;
		_tmp11_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp9_, (gpointer) ((gintptr) _tmp10_));
		_tmp12_ = _g_object_ref0 ((soyatomsColor*) _tmp11_);
		_g_object_unref0 (ret);
		ret = _tmp12_;
	} else {
		gint _tmp13_;
		_tmp13_ = self->priv->_chans;
		if (_tmp13_ == 1) {
			guchar* _tmp14_;
			gint _tmp15_;
			guchar _tmp16_;
			guchar l;
			guchar _tmp17_;
			guchar _tmp18_;
			guchar _tmp19_;
			soyatomsColor* _tmp20_;
			_tmp14_ = self->texels;
			_tmp15_ = index;
			_tmp16_ = _tmp14_[_tmp15_];
			l = _tmp16_;
			_tmp17_ = l;
			_tmp18_ = l;
			_tmp19_ = l;
			_tmp20_ = soy_atoms_color_new (_tmp17_, _tmp18_, _tmp19_, (guchar) 255);
			_g_object_unref0 (ret);
			ret = _tmp20_;
		} else {
			gint _tmp21_;
			_tmp21_ = self->priv->_chans;
			if (_tmp21_ == 2) {
				guchar* _tmp22_;
				gint _tmp23_;
				guchar _tmp24_;
				guchar l;
				guchar* _tmp25_;
				gint _tmp26_;
				guchar _tmp27_;
				guchar a;
				guchar _tmp28_;
				guchar _tmp29_;
				guchar _tmp30_;
				guchar _tmp31_;
				soyatomsColor* _tmp32_;
				_tmp22_ = self->texels;
				_tmp23_ = index;
				_tmp24_ = _tmp22_[_tmp23_ * 2];
				l = _tmp24_;
				_tmp25_ = self->texels;
				_tmp26_ = index;
				_tmp27_ = _tmp25_[(_tmp26_ * 2) + 1];
				a = _tmp27_;
				_tmp28_ = l;
				_tmp29_ = l;
				_tmp30_ = l;
				_tmp31_ = a;
				_tmp32_ = soy_atoms_color_new (_tmp28_, _tmp29_, _tmp30_, _tmp31_);
				_g_object_unref0 (ret);
				ret = _tmp32_;
			} else {
				gint _tmp33_;
				_tmp33_ = self->priv->_chans;
				if (_tmp33_ == 3) {
					guchar* _tmp34_;
					gint _tmp35_;
					guchar _tmp36_;
					guchar r;
					guchar* _tmp37_;
					gint _tmp38_;
					guchar _tmp39_;
					guchar g;
					guchar* _tmp40_;
					gint _tmp41_;
					guchar _tmp42_;
					guchar b;
					guchar _tmp43_;
					guchar _tmp44_;
					guchar _tmp45_;
					soyatomsColor* _tmp46_;
					_tmp34_ = self->texels;
					_tmp35_ = index;
					_tmp36_ = _tmp34_[_tmp35_ * 3];
					r = _tmp36_;
					_tmp37_ = self->texels;
					_tmp38_ = index;
					_tmp39_ = _tmp37_[(_tmp38_ * 3) + 1];
					g = _tmp39_;
					_tmp40_ = self->texels;
					_tmp41_ = index;
					_tmp42_ = _tmp40_[(_tmp41_ * 3) + 2];
					b = _tmp42_;
					_tmp43_ = r;
					_tmp44_ = g;
					_tmp45_ = b;
					_tmp46_ = soy_atoms_color_new (_tmp43_, _tmp44_, _tmp45_, (guchar) 255);
					_g_object_unref0 (ret);
					ret = _tmp46_;
				} else {
					guchar* _tmp47_;
					gint _tmp48_;
					guchar _tmp49_;
					guchar r;
					guchar* _tmp50_;
					gint _tmp51_;
					guchar _tmp52_;
					guchar g;
					guchar* _tmp53_;
					gint _tmp54_;
					guchar _tmp55_;
					guchar b;
					guchar* _tmp56_;
					gint _tmp57_;
					guchar _tmp58_;
					guchar a;
					guchar _tmp59_;
					guchar _tmp60_;
					guchar _tmp61_;
					guchar _tmp62_;
					soyatomsColor* _tmp63_;
					_tmp47_ = self->texels;
					_tmp48_ = index;
					_tmp49_ = _tmp47_[_tmp48_ * 4];
					r = _tmp49_;
					_tmp50_ = self->texels;
					_tmp51_ = index;
					_tmp52_ = _tmp50_[(_tmp51_ * 4) + 1];
					g = _tmp52_;
					_tmp53_ = self->texels;
					_tmp54_ = index;
					_tmp55_ = _tmp53_[(_tmp54_ * 4) + 2];
					b = _tmp55_;
					_tmp56_ = self->texels;
					_tmp57_ = index;
					_tmp58_ = _tmp56_[(_tmp57_ * 4) + 3];
					a = _tmp58_;
					_tmp59_ = r;
					_tmp60_ = g;
					_tmp61_ = b;
					_tmp62_ = a;
					_tmp63_ = soy_atoms_color_new (_tmp59_, _tmp60_, _tmp61_, _tmp62_);
					_g_object_unref0 (ret);
					ret = _tmp63_;
				}
			}
		}
	}
	_tmp64_ = ret;
	g_signal_connect_object (_tmp64_, "on-set", (GCallback) __soy_textures_texture_texel_set_soy_atoms_color_on_set, self, 0);
	_tmp65_ = ret;
	g_object_weak_ref ((GObject*) _tmp65_, __soy_textures_texture_texel_weak_gweak_notify, self);
	_tmp66_ = self->priv->_texel_objs;
	_tmp67_ = index;
	_tmp68_ = ret;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp66_, (gpointer) ((gintptr) _tmp67_), _tmp68_);
	_tmp69_ = ret;
	ret = NULL;
	result = _tmp69_;
	_g_object_unref0 (ret);
	return result;
}


void soy_textures_texture_set (soytexturesTexture* self, gint index, GObject* value) {
	soyatomsColor* color = NULL;
	GObject* _tmp0_;
	GObject* _tmp1_;
	soyatomsColor* _tmp2_;
	GeeHashMap* _tmp3_;
	gint _tmp4_;
	gboolean _tmp5_ = FALSE;
	GeeHashMap* _tmp13_;
	gint _tmp14_;
	soyatomsColor* _tmp15_;
	soyatomsColor* _tmp16_;
	soyatomsColor* _tmp17_;
	gint _tmp18_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = value;
	if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, SOY_ATOMS_TYPE_COLOR)) {
		_g_object_unref0 (color);
		return;
	}
	_tmp1_ = value;
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, SOY_ATOMS_TYPE_COLOR, soyatomsColor));
	_g_object_unref0 (color);
	color = _tmp2_;
	_tmp3_ = self->priv->_texel_objs;
	_tmp4_ = index;
	_tmp5_ = gee_abstract_map_has_key ((GeeAbstractMap*) _tmp3_, (gpointer) ((gintptr) _tmp4_));
	if (_tmp5_) {
		GeeHashMap* _tmp6_;
		gint _tmp7_;
		gpointer _tmp8_ = NULL;
		soyatomsColor* _tmp9_;
		soyatomsColor* old;
		soyatomsColor* _tmp10_;
		guint _tmp11_ = 0U;
		soyatomsColor* _tmp12_;
		_tmp6_ = self->priv->_texel_objs;
		_tmp7_ = index;
		_tmp8_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp6_, (gpointer) ((gintptr) _tmp7_));
		_tmp9_ = _g_object_ref0 ((soyatomsColor*) _tmp8_);
		old = _tmp9_;
		_tmp10_ = old;
		g_signal_parse_name ("on-set", SOY_ATOMS_TYPE_COLOR, &_tmp11_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp10_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp11_, 0, NULL, (GCallback) __soy_textures_texture_texel_set_soy_atoms_color_on_set, self);
		_tmp12_ = old;
		g_object_weak_unref ((GObject*) _tmp12_, __soy_textures_texture_texel_weak_gweak_notify, self);
		_g_object_unref0 (old);
	}
	_tmp13_ = self->priv->_texel_objs;
	_tmp14_ = index;
	_tmp15_ = color;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp13_, (gpointer) ((gintptr) _tmp14_), _tmp15_);
	_tmp16_ = color;
	g_signal_connect_object (_tmp16_, "on-set", (GCallback) __soy_textures_texture_texel_set_soy_atoms_color_on_set, self, 0);
	_tmp17_ = color;
	g_object_weak_ref ((GObject*) _tmp17_, __soy_textures_texture_texel_weak_gweak_notify, self);
	_tmp18_ = self->priv->_chans;
	if (_tmp18_ == 1) {
		guchar* _tmp19_;
		gint _tmp20_;
		soyatomsColor* _tmp21_;
		guchar _tmp22_;
		guchar _tmp23_;
		guchar _tmp24_;
		_tmp19_ = self->texels;
		_tmp20_ = index;
		_tmp21_ = color;
		_tmp22_ = soy_atoms_color_get_luma (_tmp21_);
		_tmp23_ = _tmp22_;
		_tmp19_[_tmp20_] = _tmp23_;
		_tmp24_ = _tmp19_[_tmp20_];
	} else {
		gint _tmp25_;
		_tmp25_ = self->priv->_chans;
		if (_tmp25_ == 2) {
			guchar* _tmp26_;
			gint _tmp27_;
			soyatomsColor* _tmp28_;
			guchar _tmp29_;
			guchar _tmp30_;
			guchar _tmp31_;
			guchar* _tmp32_;
			gint _tmp33_;
			soyatomsColor* _tmp34_;
			guchar _tmp35_;
			guchar _tmp36_;
			guchar _tmp37_;
			_tmp26_ = self->texels;
			_tmp27_ = index;
			_tmp28_ = color;
			_tmp29_ = soy_atoms_color_get_luma (_tmp28_);
			_tmp30_ = _tmp29_;
			_tmp26_[_tmp27_ * 2] = _tmp30_;
			_tmp31_ = _tmp26_[_tmp27_ * 2];
			_tmp32_ = self->texels;
			_tmp33_ = index;
			_tmp34_ = color;
			_tmp35_ = soy_atoms_color_get_alpha (_tmp34_);
			_tmp36_ = _tmp35_;
			_tmp32_[(_tmp33_ * 2) + 1] = _tmp36_;
			_tmp37_ = _tmp32_[(_tmp33_ * 2) + 1];
		} else {
			gint _tmp38_;
			_tmp38_ = self->priv->_chans;
			if (_tmp38_ == 3) {
				guchar* _tmp39_;
				gint _tmp40_;
				soyatomsColor* _tmp41_;
				guchar _tmp42_;
				guchar _tmp43_;
				guchar _tmp44_;
				guchar* _tmp45_;
				gint _tmp46_;
				soyatomsColor* _tmp47_;
				guchar _tmp48_;
				guchar _tmp49_;
				guchar _tmp50_;
				guchar* _tmp51_;
				gint _tmp52_;
				soyatomsColor* _tmp53_;
				guchar _tmp54_;
				guchar _tmp55_;
				guchar _tmp56_;
				_tmp39_ = self->texels;
				_tmp40_ = index;
				_tmp41_ = color;
				_tmp42_ = soy_atoms_color_get_red (_tmp41_);
				_tmp43_ = _tmp42_;
				_tmp39_[_tmp40_ * 3] = _tmp43_;
				_tmp44_ = _tmp39_[_tmp40_ * 3];
				_tmp45_ = self->texels;
				_tmp46_ = index;
				_tmp47_ = color;
				_tmp48_ = soy_atoms_color_get_green (_tmp47_);
				_tmp49_ = _tmp48_;
				_tmp45_[(_tmp46_ * 3) + 1] = _tmp49_;
				_tmp50_ = _tmp45_[(_tmp46_ * 3) + 1];
				_tmp51_ = self->texels;
				_tmp52_ = index;
				_tmp53_ = color;
				_tmp54_ = soy_atoms_color_get_blue (_tmp53_);
				_tmp55_ = _tmp54_;
				_tmp51_[(_tmp52_ * 3) + 2] = _tmp55_;
				_tmp56_ = _tmp51_[(_tmp52_ * 3) + 2];
			} else {
				guchar* _tmp57_;
				gint _tmp58_;
				soyatomsColor* _tmp59_;
				guchar _tmp60_;
				guchar _tmp61_;
				guchar _tmp62_;
				guchar* _tmp63_;
				gint _tmp64_;
				soyatomsColor* _tmp65_;
				guchar _tmp66_;
				guchar _tmp67_;
				guchar _tmp68_;
				guchar* _tmp69_;
				gint _tmp70_;
				soyatomsColor* _tmp71_;
				guchar _tmp72_;
				guchar _tmp73_;
				guchar _tmp74_;
				guchar* _tmp75_;
				gint _tmp76_;
				soyatomsColor* _tmp77_;
				guchar _tmp78_;
				guchar _tmp79_;
				guchar _tmp80_;
				_tmp57_ = self->texels;
				_tmp58_ = index;
				_tmp59_ = color;
				_tmp60_ = soy_atoms_color_get_red (_tmp59_);
				_tmp61_ = _tmp60_;
				_tmp57_[_tmp58_ * 4] = _tmp61_;
				_tmp62_ = _tmp57_[_tmp58_ * 4];
				_tmp63_ = self->texels;
				_tmp64_ = index;
				_tmp65_ = color;
				_tmp66_ = soy_atoms_color_get_green (_tmp65_);
				_tmp67_ = _tmp66_;
				_tmp63_[(_tmp64_ * 4) + 1] = _tmp67_;
				_tmp68_ = _tmp63_[(_tmp64_ * 4) + 1];
				_tmp69_ = self->texels;
				_tmp70_ = index;
				_tmp71_ = color;
				_tmp72_ = soy_atoms_color_get_blue (_tmp71_);
				_tmp73_ = _tmp72_;
				_tmp69_[(_tmp70_ * 4) + 2] = _tmp73_;
				_tmp74_ = _tmp69_[(_tmp70_ * 4) + 2];
				_tmp75_ = self->texels;
				_tmp76_ = index;
				_tmp77_ = color;
				_tmp78_ = soy_atoms_color_get_alpha (_tmp77_);
				_tmp79_ = _tmp78_;
				_tmp75_[(_tmp76_ * 4) + 3] = _tmp79_;
				_tmp80_ = _tmp75_[(_tmp76_ * 4) + 3];
			}
		}
	}
	g_mutex_lock (&self->priv->_mutex);
	self->updated = TRUE;
	g_mutex_unlock (&self->priv->_mutex);
	_g_object_unref0 (color);
}


static void _soy_textures_texture_copySurface (soytexturesTexture* self, cairo_surface_t* surface) {
	gint chans = 0;
	gint width = 0;
	gint height = 0;
	gint stride = 0;
	guchar* data = NULL;
	cairo_surface_t* _tmp0_;
	cairo_surface_t* _tmp1_;
	cairo_format_t _tmp2_ = 0;
	cairo_surface_t* _tmp3_;
	gint _tmp4_ = 0;
	cairo_surface_t* _tmp5_;
	gint _tmp6_ = 0;
	cairo_surface_t* _tmp7_;
	gint _tmp8_ = 0;
	cairo_surface_t* _tmp9_;
	guchar* _tmp10_ = NULL;
	gint _tmp11_;
	gint _tmp12_;
	gint _tmp13_ = 0;
	gint _tmp14_;
	gint _tmp15_ = 0;
	gint _tmp16_;
	gint _tmp54_;
	gint _tmp55_;
	gint _tmp56_;
	GLsizei _tmp57_;
	gint _tmp58_;
	GLsizei _tmp59_;
	gboolean _tmp60_ = FALSE;
	GLfloat _tmp61_;
	gboolean _tmp63_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (surface != NULL);
	_tmp0_ = surface;
	cairo_surface_flush (_tmp0_);
	_tmp1_ = surface;
	_tmp2_ = cairo_image_surface_get_format (_tmp1_);
	if (_tmp2_ == CAIRO_FORMAT_RGB24) {
		chans = 3;
	} else {
		chans = 4;
	}
	_tmp3_ = surface;
	_tmp4_ = cairo_image_surface_get_width (_tmp3_);
	width = _tmp4_;
	_tmp5_ = surface;
	_tmp6_ = cairo_image_surface_get_height (_tmp5_);
	height = _tmp6_;
	_tmp7_ = surface;
	_tmp8_ = cairo_image_surface_get_stride (_tmp7_);
	stride = _tmp8_;
	_tmp9_ = surface;
	_tmp10_ = cairo_image_surface_get_data (_tmp9_);
	data = (void*) _tmp10_;
	_tmp11_ = chans;
	_tmp12_ = width;
	_tmp13_ = soy_textures_texture_squareup (_tmp12_);
	_tmp14_ = height;
	_tmp15_ = soy_textures_texture_squareup (_tmp14_);
	soy_textures_texture_resize (self, _tmp11_, _tmp13_, _tmp15_);
	_tmp16_ = self->priv->_chans;
	if (_tmp16_ == 3) {
		{
			gint y;
			y = 0;
			{
				gboolean _tmp17_;
				_tmp17_ = TRUE;
				while (TRUE) {
					gboolean _tmp18_;
					gint _tmp20_;
					_tmp18_ = _tmp17_;
					if (!_tmp18_) {
						gint _tmp19_;
						_tmp19_ = y;
						y = _tmp19_ + 1;
					}
					_tmp17_ = FALSE;
					_tmp20_ = height;
					if (!(y <= (_tmp20_ - 1))) {
						break;
					}
					{
						gint x;
						x = 0;
						{
							gboolean _tmp21_;
							_tmp21_ = TRUE;
							while (TRUE) {
								gboolean _tmp22_;
								gint _tmp24_;
								gint _tmp25_;
								gint _tmp26_;
								gint _tmp27_;
								gint src;
								gint _tmp28_;
								GLsizei _tmp29_;
								gint _tmp30_;
								gint _tmp31_;
								gint dst;
								guchar* _tmp32_;
								gint _tmp33_;
								guchar* _tmp34_;
								gint _tmp35_;
								guchar _tmp36_;
								guchar* _tmp37_;
								gint _tmp38_;
								guchar* _tmp39_;
								gint _tmp40_;
								guchar _tmp41_;
								guchar* _tmp42_;
								gint _tmp43_;
								guchar* _tmp44_;
								gint _tmp45_;
								guchar _tmp46_;
								_tmp22_ = _tmp21_;
								if (!_tmp22_) {
									gint _tmp23_;
									_tmp23_ = x;
									x = _tmp23_ + 1;
								}
								_tmp21_ = FALSE;
								_tmp24_ = width;
								if (!(x <= (_tmp24_ - 1))) {
									break;
								}
								_tmp25_ = y;
								_tmp26_ = stride;
								_tmp27_ = x;
								src = (_tmp25_ * _tmp26_) + (_tmp27_ * 4);
								_tmp28_ = y;
								_tmp29_ = self->priv->_width;
								_tmp30_ = x;
								_tmp31_ = self->priv->_chans;
								dst = ((_tmp28_ * _tmp29_) + _tmp30_) * _tmp31_;
								_tmp32_ = self->texels;
								_tmp33_ = dst;
								_tmp34_ = data;
								_tmp35_ = src;
								_tmp32_[_tmp33_] = *((_tmp34_ + _tmp35_) + 2);
								_tmp36_ = _tmp32_[_tmp33_];
								_tmp37_ = self->texels;
								_tmp38_ = dst;
								_tmp39_ = data;
								_tmp40_ = src;
								_tmp37_[_tmp38_ + 1] = *((_tmp39_ + _tmp40_) + 1);
								_tmp41_ = _tmp37_[_tmp38_ + 1];
								_tmp42_ = self->texels;
								_tmp43_ = dst;
								_tmp44_ = data;
								_tmp45_ = src;
								_tmp42_[_tmp43_ + 2] = *(_tmp44_ + _tmp45_);
								_tmp46_ = _tmp42_[_tmp43_ + 2];
							}
						}
					}
				}
			}
		}
	} else {
		guchar* _tmp47_;
		GLsizei _tmp48_;
		gint _tmp49_;
		guchar* _tmp50_;
		gint _tmp51_;
		gint _tmp52_;
		gint _tmp53_;
		_tmp47_ = self->texels;
		_tmp48_ = self->priv->_width;
		_tmp49_ = self->priv->_chans;
		_tmp50_ = data;
		_tmp51_ = stride;
		_tmp52_ = width;
		_tmp53_ = height;
		soy_textures_texture_surface2rgba (_tmp47_, (gint) (_tmp48_ * _tmp49_), _tmp50_, _tmp51_, _tmp52_, _tmp53_);
	}
	_tmp54_ = width;
	_tmp55_ = height;
	self->priv->_aspect = ((gfloat) _tmp54_) / ((gfloat) _tmp55_);
	_tmp56_ = width;
	_tmp57_ = self->priv->_width;
	self->priv->_scaleX = (GLfloat) (((gfloat) _tmp56_) / ((gfloat) _tmp57_));
	_tmp58_ = height;
	_tmp59_ = self->priv->_height;
	self->priv->_scaleY = (GLfloat) (((gfloat) _tmp58_) / ((gfloat) _tmp59_));
	_tmp61_ = self->priv->_scaleX;
	if (_tmp61_ == ((GLfloat) 1.0f)) {
		GLfloat _tmp62_;
		_tmp62_ = self->priv->_scaleY;
		_tmp60_ = _tmp62_ == ((GLfloat) 1.0f);
	} else {
		_tmp60_ = FALSE;
	}
	_tmp63_ = _tmp60_;
	if (_tmp63_) {
		self->priv->_scaleX = (GLfloat) 0.0f;
	}
}


static void _soy_textures_texture_texel_set (soytexturesTexture* self, soyatomsColor* color) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (color != NULL);
	_tmp0_ = self->priv->_chans;
	if (_tmp0_ == 1) {
		{
			GeeHashMap* _tmp1_;
			GeeSet* _tmp2_;
			GeeSet* _tmp3_;
			GeeSet* _tmp4_;
			GeeIterator* _tmp5_ = NULL;
			GeeIterator* _tmp6_;
			GeeIterator* _index_it;
			_tmp1_ = self->priv->_texel_objs;
			_tmp2_ = gee_abstract_map_get_keys ((GeeMap*) _tmp1_);
			_tmp3_ = _tmp2_;
			_tmp4_ = _tmp3_;
			_tmp5_ = gee_iterable_iterator ((GeeIterable*) _tmp4_);
			_tmp6_ = _tmp5_;
			_g_object_unref0 (_tmp4_);
			_index_it = _tmp6_;
			while (TRUE) {
				GeeIterator* _tmp7_;
				gboolean _tmp8_ = FALSE;
				GeeIterator* _tmp9_;
				gpointer _tmp10_ = NULL;
				gint index;
				GeeHashMap* _tmp11_;
				gint _tmp12_;
				gpointer _tmp13_ = NULL;
				soyatomsColor* _tmp14_;
				_tmp7_ = _index_it;
				_tmp8_ = gee_iterator_next (_tmp7_);
				if (!_tmp8_) {
					break;
				}
				_tmp9_ = _index_it;
				_tmp10_ = gee_iterator_get (_tmp9_);
				index = (gint) ((gintptr) _tmp10_);
				_tmp11_ = self->priv->_texel_objs;
				_tmp12_ = index;
				_tmp13_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp11_, (gpointer) ((gintptr) _tmp12_));
				_tmp14_ = color;
				if (((soyatomsColor*) _tmp13_) == _tmp14_) {
					guchar* _tmp15_;
					gint _tmp16_;
					soyatomsColor* _tmp17_;
					guchar _tmp18_;
					guchar _tmp19_;
					guchar _tmp20_;
					_tmp15_ = self->texels;
					_tmp16_ = index;
					_tmp17_ = color;
					_tmp18_ = soy_atoms_color_get_luma (_tmp17_);
					_tmp19_ = _tmp18_;
					_tmp15_[_tmp16_] = _tmp19_;
					_tmp20_ = _tmp15_[_tmp16_];
				}
			}
			_g_object_unref0 (_index_it);
		}
	} else {
		gint _tmp21_;
		_tmp21_ = self->priv->_chans;
		if (_tmp21_ == 2) {
			{
				GeeHashMap* _tmp22_;
				GeeSet* _tmp23_;
				GeeSet* _tmp24_;
				GeeSet* _tmp25_;
				GeeIterator* _tmp26_ = NULL;
				GeeIterator* _tmp27_;
				GeeIterator* _index_it;
				_tmp22_ = self->priv->_texel_objs;
				_tmp23_ = gee_abstract_map_get_keys ((GeeMap*) _tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = _tmp24_;
				_tmp26_ = gee_iterable_iterator ((GeeIterable*) _tmp25_);
				_tmp27_ = _tmp26_;
				_g_object_unref0 (_tmp25_);
				_index_it = _tmp27_;
				while (TRUE) {
					GeeIterator* _tmp28_;
					gboolean _tmp29_ = FALSE;
					GeeIterator* _tmp30_;
					gpointer _tmp31_ = NULL;
					gint index;
					GeeHashMap* _tmp32_;
					gint _tmp33_;
					gpointer _tmp34_ = NULL;
					soyatomsColor* _tmp35_;
					_tmp28_ = _index_it;
					_tmp29_ = gee_iterator_next (_tmp28_);
					if (!_tmp29_) {
						break;
					}
					_tmp30_ = _index_it;
					_tmp31_ = gee_iterator_get (_tmp30_);
					index = (gint) ((gintptr) _tmp31_);
					_tmp32_ = self->priv->_texel_objs;
					_tmp33_ = index;
					_tmp34_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp32_, (gpointer) ((gintptr) _tmp33_));
					_tmp35_ = color;
					if (((soyatomsColor*) _tmp34_) == _tmp35_) {
						guchar* _tmp36_;
						gint _tmp37_;
						soyatomsColor* _tmp38_;
						guchar _tmp39_;
						guchar _tmp40_;
						guchar _tmp41_;
						guchar* _tmp42_;
						gint _tmp43_;
						soyatomsColor* _tmp44_;
						guchar _tmp45_;
						guchar _tmp46_;
						guchar _tmp47_;
						_tmp36_ = self->texels;
						_tmp37_ = index;
						_tmp38_ = color;
						_tmp39_ = soy_atoms_color_get_luma (_tmp38_);
						_tmp40_ = _tmp39_;
						_tmp36_[_tmp37_ * 2] = _tmp40_;
						_tmp41_ = _tmp36_[_tmp37_ * 2];
						_tmp42_ = self->texels;
						_tmp43_ = index;
						_tmp44_ = color;
						_tmp45_ = soy_atoms_color_get_alpha (_tmp44_);
						_tmp46_ = _tmp45_;
						_tmp42_[(_tmp43_ * 2) + 1] = _tmp46_;
						_tmp47_ = _tmp42_[(_tmp43_ * 2) + 1];
					}
				}
				_g_object_unref0 (_index_it);
			}
		} else {
			gint _tmp48_;
			_tmp48_ = self->priv->_chans;
			if (_tmp48_ == 3) {
				{
					GeeHashMap* _tmp49_;
					GeeSet* _tmp50_;
					GeeSet* _tmp51_;
					GeeSet* _tmp52_;
					GeeIterator* _tmp53_ = NULL;
					GeeIterator* _tmp54_;
					GeeIterator* _index_it;
					_tmp49_ = self->priv->_texel_objs;
					_tmp50_ = gee_abstract_map_get_keys ((GeeMap*) _tmp49_);
					_tmp51_ = _tmp50_;
					_tmp52_ = _tmp51_;
					_tmp53_ = gee_iterable_iterator ((GeeIterable*) _tmp52_);
					_tmp54_ = _tmp53_;
					_g_object_unref0 (_tmp52_);
					_index_it = _tmp54_;
					while (TRUE) {
						GeeIterator* _tmp55_;
						gboolean _tmp56_ = FALSE;
						GeeIterator* _tmp57_;
						gpointer _tmp58_ = NULL;
						gint index;
						GeeHashMap* _tmp59_;
						gint _tmp60_;
						gpointer _tmp61_ = NULL;
						soyatomsColor* _tmp62_;
						_tmp55_ = _index_it;
						_tmp56_ = gee_iterator_next (_tmp55_);
						if (!_tmp56_) {
							break;
						}
						_tmp57_ = _index_it;
						_tmp58_ = gee_iterator_get (_tmp57_);
						index = (gint) ((gintptr) _tmp58_);
						_tmp59_ = self->priv->_texel_objs;
						_tmp60_ = index;
						_tmp61_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp59_, (gpointer) ((gintptr) _tmp60_));
						_tmp62_ = color;
						if (((soyatomsColor*) _tmp61_) == _tmp62_) {
							guchar* _tmp63_;
							gint _tmp64_;
							soyatomsColor* _tmp65_;
							guchar _tmp66_;
							guchar _tmp67_;
							guchar _tmp68_;
							guchar* _tmp69_;
							gint _tmp70_;
							soyatomsColor* _tmp71_;
							guchar _tmp72_;
							guchar _tmp73_;
							guchar _tmp74_;
							guchar* _tmp75_;
							gint _tmp76_;
							soyatomsColor* _tmp77_;
							guchar _tmp78_;
							guchar _tmp79_;
							guchar _tmp80_;
							_tmp63_ = self->texels;
							_tmp64_ = index;
							_tmp65_ = color;
							_tmp66_ = soy_atoms_color_get_red (_tmp65_);
							_tmp67_ = _tmp66_;
							_tmp63_[_tmp64_ * 3] = _tmp67_;
							_tmp68_ = _tmp63_[_tmp64_ * 3];
							_tmp69_ = self->texels;
							_tmp70_ = index;
							_tmp71_ = color;
							_tmp72_ = soy_atoms_color_get_green (_tmp71_);
							_tmp73_ = _tmp72_;
							_tmp69_[(_tmp70_ * 3) + 1] = _tmp73_;
							_tmp74_ = _tmp69_[(_tmp70_ * 3) + 1];
							_tmp75_ = self->texels;
							_tmp76_ = index;
							_tmp77_ = color;
							_tmp78_ = soy_atoms_color_get_blue (_tmp77_);
							_tmp79_ = _tmp78_;
							_tmp75_[(_tmp76_ * 3) + 2] = _tmp79_;
							_tmp80_ = _tmp75_[(_tmp76_ * 3) + 2];
						}
					}
					_g_object_unref0 (_index_it);
				}
			} else {
				{
					GeeHashMap* _tmp81_;
					GeeSet* _tmp82_;
					GeeSet* _tmp83_;
					GeeSet* _tmp84_;
					GeeIterator* _tmp85_ = NULL;
					GeeIterator* _tmp86_;
					GeeIterator* _index_it;
					_tmp81_ = self->priv->_texel_objs;
					_tmp82_ = gee_abstract_map_get_keys ((GeeMap*) _tmp81_);
					_tmp83_ = _tmp82_;
					_tmp84_ = _tmp83_;
					_tmp85_ = gee_iterable_iterator ((GeeIterable*) _tmp84_);
					_tmp86_ = _tmp85_;
					_g_object_unref0 (_tmp84_);
					_index_it = _tmp86_;
					while (TRUE) {
						GeeIterator* _tmp87_;
						gboolean _tmp88_ = FALSE;
						GeeIterator* _tmp89_;
						gpointer _tmp90_ = NULL;
						gint index;
						GeeHashMap* _tmp91_;
						gint _tmp92_;
						gpointer _tmp93_ = NULL;
						soyatomsColor* _tmp94_;
						_tmp87_ = _index_it;
						_tmp88_ = gee_iterator_next (_tmp87_);
						if (!_tmp88_) {
							break;
						}
						_tmp89_ = _index_it;
						_tmp90_ = gee_iterator_get (_tmp89_);
						index = (gint) ((gintptr) _tmp90_);
						_tmp91_ = self->priv->_texel_objs;
						_tmp92_ = index;
						_tmp93_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp91_, (gpointer) ((gintptr) _tmp92_));
						_tmp94_ = color;
						if (((soyatomsColor*) _tmp93_) == _tmp94_) {
							guchar* _tmp95_;
							gint _tmp96_;
							soyatomsColor* _tmp97_;
							guchar _tmp98_;
							guchar _tmp99_;
							guchar _tmp100_;
							guchar* _tmp101_;
							gint _tmp102_;
							soyatomsColor* _tmp103_;
							guchar _tmp104_;
							guchar _tmp105_;
							guchar _tmp106_;
							guchar* _tmp107_;
							gint _tmp108_;
							soyatomsColor* _tmp109_;
							guchar _tmp110_;
							guchar _tmp111_;
							guchar _tmp112_;
							guchar* _tmp113_;
							gint _tmp114_;
							soyatomsColor* _tmp115_;
							guchar _tmp116_;
							guchar _tmp117_;
							guchar _tmp118_;
							_tmp95_ = self->texels;
							_tmp96_ = index;
							_tmp97_ = color;
							_tmp98_ = soy_atoms_color_get_red (_tmp97_);
							_tmp99_ = _tmp98_;
							_tmp95_[_tmp96_ * 4] = _tmp99_;
							_tmp100_ = _tmp95_[_tmp96_ * 4];
							_tmp101_ = self->texels;
							_tmp102_ = index;
							_tmp103_ = color;
							_tmp104_ = soy_atoms_color_get_green (_tmp103_);
							_tmp105_ = _tmp104_;
							_tmp101_[(_tmp102_ * 4) + 1] = _tmp105_;
							_tmp106_ = _tmp101_[(_tmp102_ * 4) + 1];
							_tmp107_ = self->texels;
							_tmp108_ = index;
							_tmp109_ = color;
							_tmp110_ = soy_atoms_color_get_blue (_tmp109_);
							_tmp111_ = _tmp110_;
							_tmp107_[(_tmp108_ * 4) + 2] = _tmp111_;
							_tmp112_ = _tmp107_[(_tmp108_ * 4) + 2];
							_tmp113_ = self->texels;
							_tmp114_ = index;
							_tmp115_ = color;
							_tmp116_ = soy_atoms_color_get_alpha (_tmp115_);
							_tmp117_ = _tmp116_;
							_tmp113_[(_tmp114_ * 4) + 3] = _tmp117_;
							_tmp118_ = _tmp113_[(_tmp114_ * 4) + 3];
						}
					}
					_g_object_unref0 (_index_it);
				}
			}
		}
	}
	g_mutex_lock (&self->priv->_mutex);
	self->updated = TRUE;
	g_mutex_unlock (&self->priv->_mutex);
}


static void _soy_textures_texture_texel_weak (soytexturesTexture* self, GObject* color) {
	GeeArrayList* _tmp0_;
	GeeArrayList* garbage;
	g_return_if_fail (self != NULL);
	g_return_if_fail (color != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_INT, NULL, NULL, NULL);
	garbage = _tmp0_;
	{
		GeeHashMap* _tmp1_;
		GeeSet* _tmp2_;
		GeeSet* _tmp3_;
		GeeSet* _tmp4_;
		GeeIterator* _tmp5_ = NULL;
		GeeIterator* _tmp6_;
		GeeIterator* _index_it;
		_tmp1_ = self->priv->_texel_objs;
		_tmp2_ = gee_abstract_map_get_keys ((GeeMap*) _tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = _tmp3_;
		_tmp5_ = gee_iterable_iterator ((GeeIterable*) _tmp4_);
		_tmp6_ = _tmp5_;
		_g_object_unref0 (_tmp4_);
		_index_it = _tmp6_;
		while (TRUE) {
			GeeIterator* _tmp7_;
			gboolean _tmp8_ = FALSE;
			GeeIterator* _tmp9_;
			gpointer _tmp10_ = NULL;
			gint index;
			GeeHashMap* _tmp11_;
			gint _tmp12_;
			gpointer _tmp13_ = NULL;
			GObject* _tmp14_;
			_tmp7_ = _index_it;
			_tmp8_ = gee_iterator_next (_tmp7_);
			if (!_tmp8_) {
				break;
			}
			_tmp9_ = _index_it;
			_tmp10_ = gee_iterator_get (_tmp9_);
			index = (gint) ((gintptr) _tmp10_);
			_tmp11_ = self->priv->_texel_objs;
			_tmp12_ = index;
			_tmp13_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp11_, (gpointer) ((gintptr) _tmp12_));
			_tmp14_ = color;
			if (G_TYPE_CHECK_INSTANCE_CAST ((soyatomsColor*) _tmp13_, G_TYPE_OBJECT, GObject) == _tmp14_) {
				GeeArrayList* _tmp15_;
				gint _tmp16_;
				_tmp15_ = garbage;
				_tmp16_ = index;
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp15_, (gpointer) ((gintptr) _tmp16_));
			}
		}
		_g_object_unref0 (_index_it);
	}
	{
		GeeArrayList* _tmp17_;
		GeeArrayList* _tmp18_;
		GeeArrayList* _index_list;
		GeeArrayList* _tmp19_;
		gint _tmp20_;
		gint _tmp21_;
		gint _index_size;
		gint _index_index;
		_tmp17_ = garbage;
		_tmp18_ = _g_object_ref0 (_tmp17_);
		_index_list = _tmp18_;
		_tmp19_ = _index_list;
		_tmp20_ = gee_abstract_collection_get_size ((GeeCollection*) _tmp19_);
		_tmp21_ = _tmp20_;
		_index_size = _tmp21_;
		_index_index = -1;
		while (TRUE) {
			gint _tmp22_;
			gint _tmp23_;
			gint _tmp24_;
			GeeArrayList* _tmp25_;
			gint _tmp26_;
			gpointer _tmp27_ = NULL;
			gint index;
			GeeHashMap* _tmp28_;
			gint _tmp29_;
			_tmp22_ = _index_index;
			_index_index = _tmp22_ + 1;
			_tmp23_ = _index_index;
			_tmp24_ = _index_size;
			if (!(_tmp23_ < _tmp24_)) {
				break;
			}
			_tmp25_ = _index_list;
			_tmp26_ = _index_index;
			_tmp27_ = gee_abstract_list_get ((GeeAbstractList*) _tmp25_, _tmp26_);
			index = (gint) ((gintptr) _tmp27_);
			_tmp28_ = self->priv->_texel_objs;
			_tmp29_ = index;
			gee_abstract_map_unset ((GeeAbstractMap*) _tmp28_, (gpointer) ((gintptr) _tmp29_), NULL);
		}
		_g_object_unref0 (_index_list);
	}
	_g_object_unref0 (garbage);
}


void soy_textures_texture_resize (soytexturesTexture* self, gint c, gint x, gint y) {
	gint size = 0;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp22_;
	gint _tmp23_;
	gint _tmp24_;
	g_return_if_fail (self != NULL);
	g_mutex_lock (&self->priv->_mutex);
	_tmp0_ = c;
	_tmp1_ = x;
	_tmp2_ = y;
	size = (_tmp0_ * _tmp1_) * _tmp2_;
	_tmp3_ = size;
	if (_tmp3_ == 0) {
		GLsizei _tmp4_;
		_tmp4_ = self->priv->_width;
		if (_tmp4_ != ((GLsizei) 0)) {
			guchar* _tmp5_;
			_tmp5_ = self->texels;
			g_free (_tmp5_);
			self->texels = NULL;
		}
	} else {
		GLsizei _tmp6_;
		_tmp6_ = self->priv->_width;
		if (_tmp6_ != ((GLsizei) 0)) {
			gboolean _tmp7_ = FALSE;
			gboolean _tmp8_ = FALSE;
			gint _tmp9_;
			gint _tmp10_;
			gboolean _tmp13_;
			gboolean _tmp16_;
			_tmp9_ = self->priv->_chans;
			_tmp10_ = c;
			if (_tmp9_ != _tmp10_) {
				_tmp8_ = TRUE;
			} else {
				GLsizei _tmp11_;
				gint _tmp12_;
				_tmp11_ = self->priv->_width;
				_tmp12_ = x;
				_tmp8_ = _tmp11_ != ((GLsizei) _tmp12_);
			}
			_tmp13_ = _tmp8_;
			if (_tmp13_) {
				_tmp7_ = TRUE;
			} else {
				GLsizei _tmp14_;
				gint _tmp15_;
				_tmp14_ = self->priv->_height;
				_tmp15_ = y;
				_tmp7_ = _tmp14_ != ((GLsizei) _tmp15_);
			}
			_tmp16_ = _tmp7_;
			if (_tmp16_) {
				guchar* _tmp17_;
				gint _tmp18_;
				void* _tmp19_ = NULL;
				_tmp17_ = self->texels;
				_tmp18_ = size;
				_tmp19_ = g_realloc (_tmp17_, (gsize) _tmp18_);
				self->texels = _tmp19_;
			}
		} else {
			gint _tmp20_;
			void* _tmp21_ = NULL;
			_tmp20_ = size;
			_tmp21_ = g_malloc0 ((gsize) _tmp20_);
			self->texels = _tmp21_;
		}
	}
	_tmp22_ = c;
	self->priv->_chans = _tmp22_;
	_tmp23_ = x;
	self->priv->_width = (GLsizei) _tmp23_;
	_tmp24_ = y;
	self->priv->_height = (GLsizei) _tmp24_;
	self->updated = TRUE;
	g_mutex_unlock (&self->priv->_mutex);
}


inline void soy_textures_texture_update (soytexturesTexture* self, GLenum target) {
	GLenum _tmp0_;
	GLenum* _tmp1_;
	gint _tmp1__length1;
	gint _tmp2_;
	GLenum _tmp3_;
	GLsizei _tmp4_;
	GLsizei _tmp5_;
	GLenum* _tmp6_;
	gint _tmp6__length1;
	gint _tmp7_;
	GLenum _tmp8_;
	guchar* _tmp9_;
	g_return_if_fail (self != NULL);
	_tmp0_ = target;
	_tmp1_ = soy_textures_texture__formats;
	_tmp1__length1 = soy_textures_texture__formats_length1;
	_tmp2_ = self->priv->_chans;
	_tmp3_ = _tmp1_[_tmp2_];
	_tmp4_ = self->priv->_width;
	_tmp5_ = self->priv->_height;
	_tmp6_ = soy_textures_texture__formats;
	_tmp6__length1 = soy_textures_texture__formats_length1;
	_tmp7_ = self->priv->_chans;
	_tmp8_ = _tmp6_[_tmp7_];
	_tmp9_ = self->texels;
	glTexImage2D (_tmp0_, (GLint) 0, (GLint) _tmp3_, _tmp4_, _tmp5_, (GLint) 0, _tmp8_, GL_UNSIGNED_BYTE, (GLvoid*) _tmp9_);
}


void soy_textures_texture_bind (soytexturesTexture* self, GLenum target) {
	GLenum _tmp0_;
	GLuint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = target;
	_tmp1_ = self->priv->_textureID;
	glBindTexture (_tmp0_, _tmp1_);
}


static void soy_textures_texture_real_enable (soytexturesTexture* self) {
	gint _i = 0;
	gfloat* _tmp0_ = NULL;
	gfloat* _anim;
	gint _anim_length1;
	gint __anim_size_;
	guchar* _tmp1_;
	GLuint _tmp6_;
	GLuint _tmp8_;
	gboolean _tmp9_;
	gboolean _tmp10_;
	gboolean _tmp11_;
	gint _tmp12_;
	GLfloat _tmp42_;
	GLfloat _tmp45_;
	_tmp0_ = g_new0 (gfloat, 3);
	_anim = _tmp0_;
	_anim_length1 = 3;
	__anim_size_ = _anim_length1;
	_tmp1_ = self->texels;
	if (_tmp1_ == NULL) {
		GLuint _tmp2_;
		_tmp2_ = self->priv->_textureID;
		if (_tmp2_ != ((GLuint) 0)) {
			GLuint _tmp3_;
			GLuint* _tmp4_ = NULL;
			GLuint* _tmp5_;
			gint _tmp5__length1;
			_tmp3_ = self->priv->_textureID;
			_tmp4_ = g_new0 (GLuint, 1);
			_tmp4_[0] = _tmp3_;
			_tmp5_ = _tmp4_;
			_tmp5__length1 = 1;
			glDeleteTextures ((GLsizei) 1, _tmp5_);
			_tmp5_ = (g_free (_tmp5_), NULL);
		}
		_anim = (g_free (_anim), NULL);
		return;
	}
	g_mutex_lock (&self->priv->_mutex);
	glEnable (GL_TEXTURE_2D);
	_tmp6_ = self->priv->_textureID;
	if (_tmp6_ == ((GLuint) 0)) {
		GLuint _tmp7_ = 0U;
		glGenTextures ((GLsizei) 1, &_tmp7_);
		self->priv->_textureID = _tmp7_;
		self->updated = TRUE;
	}
	_tmp8_ = self->priv->_textureID;
	glBindTexture (GL_TEXTURE_2D, _tmp8_);
	_tmp9_ = self->updated;
	if (_tmp9_) {
		soy_textures_texture_update (self, GL_TEXTURE_2D);
		self->updated = FALSE;
	}
	glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, (GLint) GL_LINEAR);
	_tmp10_ = self->priv->_smooth;
	if (_tmp10_) {
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLint) GL_LINEAR);
	} else {
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, (GLint) GL_NEAREST);
	}
	_tmp11_ = self->priv->_wrap;
	if (_tmp11_) {
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, (GLint) GL_REPEAT);
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, (GLint) GL_REPEAT);
	} else {
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, (GLint) GL_CLAMP_TO_EDGE);
		glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, (GLint) GL_CLAMP_TO_EDGE);
	}
	_tmp12_ = self->priv->_isAnimated;
	if (_tmp12_ == 1) {
		GTimeVal tv = {0};
		GTimeVal _tmp13_;
		glong _tmp14_;
		GTimeVal _tmp15_;
		glong _tmp16_;
		gfloat _it;
		gfloat* _tmp36_;
		gint _tmp36__length1;
		gfloat _tmp37_;
		gfloat* _tmp38_;
		gint _tmp38__length1;
		gfloat _tmp39_;
		gfloat* _tmp40_;
		gint _tmp40__length1;
		gfloat _tmp41_;
		g_get_current_time (&tv);
		_tmp13_ = tv;
		_tmp14_ = _tmp13_.tv_sec;
		_tmp15_ = tv;
		_tmp16_ = _tmp15_.tv_usec;
		_it = ((gfloat) _tmp14_) + (((gfloat) _tmp16_) / 1000000.0f);
		{
			gboolean _tmp17_;
			_i = 0;
			_tmp17_ = TRUE;
			while (TRUE) {
				gboolean _tmp18_;
				gfloat* _tmp20_;
				gint _tmp20__length1;
				gint _tmp21_;
				gfloat _tmp22_;
				GLfloat* _tmp23_;
				gint _tmp23__length1;
				gint _tmp24_;
				GLfloat _tmp25_;
				gfloat _tmp26_;
				gfloat* _tmp27_;
				gint _tmp27__length1;
				gint _tmp28_;
				gfloat* _tmp29_;
				gint _tmp29__length1;
				gint _tmp30_;
				gfloat _tmp31_;
				gfloat* _tmp32_;
				gint _tmp32__length1;
				gint _tmp33_;
				gfloat _tmp34_;
				gfloat _tmp35_;
				_tmp18_ = _tmp17_;
				if (!_tmp18_) {
					gint _tmp19_;
					_tmp19_ = _i;
					_i = _tmp19_ + 1;
				}
				_tmp17_ = FALSE;
				if (!(_i <= 3)) {
					break;
				}
				_tmp20_ = _anim;
				_tmp20__length1 = _anim_length1;
				_tmp21_ = _i;
				_tmp22_ = _it;
				_tmp23_ = self->priv->_animate;
				_tmp23__length1 = self->priv->_animate_length1;
				_tmp24_ = _i;
				_tmp25_ = _tmp23_[_tmp24_];
				_tmp20_[_tmp21_] = _tmp22_ * _tmp25_;
				_tmp26_ = _tmp20_[_tmp21_];
				_tmp27_ = _anim;
				_tmp27__length1 = _anim_length1;
				_tmp28_ = _i;
				_tmp29_ = _anim;
				_tmp29__length1 = _anim_length1;
				_tmp30_ = _i;
				_tmp31_ = _tmp29_[_tmp30_];
				_tmp32_ = _anim;
				_tmp32__length1 = _anim_length1;
				_tmp33_ = _i;
				_tmp34_ = _tmp32_[_tmp33_];
				_tmp27_[_tmp28_] = _tmp31_ - _tmp34_;
				_tmp35_ = _tmp27_[_tmp28_];
			}
		}
		glMatrixMode (GL_TEXTURE);
		_tmp36_ = _anim;
		_tmp36__length1 = _anim_length1;
		_tmp37_ = _tmp36_[0];
		_tmp38_ = _anim;
		_tmp38__length1 = _anim_length1;
		_tmp39_ = _tmp38_[1];
		_tmp40_ = _anim;
		_tmp40__length1 = _anim_length1;
		_tmp41_ = _tmp40_[2];
		glTranslatef ((GLfloat) ((gfloat) _tmp37_), (GLfloat) ((gfloat) _tmp39_), (GLfloat) ((gfloat) _tmp41_));
	}
	_tmp42_ = self->priv->_scaleX;
	if (_tmp42_ != ((GLfloat) 0)) {
		GLfloat _tmp43_;
		GLfloat _tmp44_;
		glMatrixMode (GL_TEXTURE);
		_tmp43_ = self->priv->_scaleX;
		_tmp44_ = self->priv->_scaleY;
		glScalef (_tmp43_, _tmp44_, (GLfloat) 1);
	}
	_tmp45_ = self->priv->_translateX;
	if (_tmp45_ != ((GLfloat) 0)) {
		GLfloat _tmp46_;
		GLfloat _tmp47_;
		glMatrixMode (GL_TEXTURE);
		_tmp46_ = self->priv->_translateX;
		_tmp47_ = self->priv->_translateY;
		glTranslatef (_tmp46_, _tmp47_, (GLfloat) 1);
	}
	_anim = (g_free (_anim), NULL);
}


void soy_textures_texture_enable (soytexturesTexture* self) {
	g_return_if_fail (self != NULL);
	SOY_TEXTURES_TEXTURE_GET_CLASS (self)->enable (self);
}


static void soy_textures_texture_real_disable (soytexturesTexture* self) {
	guchar* _tmp0_;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_;
	gboolean _tmp5_;
	gboolean _tmp7_;
	_tmp0_ = self->texels;
	if (_tmp0_ == NULL) {
		return;
	}
	glDisable (GL_TEXTURE_2D);
	_tmp3_ = self->priv->_isAnimated;
	if (_tmp3_ != 0) {
		_tmp2_ = TRUE;
	} else {
		GLfloat _tmp4_;
		_tmp4_ = self->priv->_scaleX;
		_tmp2_ = _tmp4_ != ((GLfloat) 0);
	}
	_tmp5_ = _tmp2_;
	if (_tmp5_) {
		_tmp1_ = TRUE;
	} else {
		GLfloat _tmp6_;
		_tmp6_ = self->priv->_translateX;
		_tmp1_ = _tmp6_ != ((GLfloat) 0);
	}
	_tmp7_ = _tmp1_;
	if (_tmp7_) {
		glMatrixMode (GL_TEXTURE);
		glLoadIdentity ();
	}
	g_mutex_unlock (&self->priv->_mutex);
}


void soy_textures_texture_disable (soytexturesTexture* self) {
	g_return_if_fail (self != NULL);
	SOY_TEXTURES_TEXTURE_GET_CLASS (self)->disable (self);
}


static guchar* _vala_array_dup11 (guchar* self, int length) {
	return g_memdup (self, length * sizeof (guchar));
}


void soy_textures_texture_load (soytexturesTexture* self, void* _vdata, gint _size) {
	guchar* _data = NULL;
	gint _data_length1 = 0;
	gint __data_size_ = 0;
	void* _tmp0_;
	guchar* _tmp1_;
	gint _tmp1__length1;
	g_return_if_fail (self != NULL);
	_tmp0_ = _vdata;
	_tmp1_ = (((guchar*) _tmp0_) != NULL) ? _vala_array_dup11 ((guchar*) _tmp0_, -1) : ((gpointer) ((guchar*) _tmp0_));
	_tmp1__length1 = -1;
	_data = (g_free (_data), NULL);
	_data = _tmp1_;
	_data_length1 = _tmp1__length1;
	__data_size_ = _data_length1;
	_data = (g_free (_data), NULL);
}


gint soy_textures_texture_squareup (gint _v) {
	gint result = 0;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	gint _tmp11_;
	_tmp0_ = _v;
	_v = _tmp0_ - 1;
	_tmp1_ = _v;
	_tmp2_ = _v;
	_v = _tmp1_ | (_tmp2_ >> 1);
	_tmp3_ = _v;
	_tmp4_ = _v;
	_v = _tmp3_ | (_tmp4_ >> 2);
	_tmp5_ = _v;
	_tmp6_ = _v;
	_v = _tmp5_ | (_tmp6_ >> 4);
	_tmp7_ = _v;
	_tmp8_ = _v;
	_v = _tmp7_ | (_tmp8_ >> 8);
	_tmp9_ = _v;
	_tmp10_ = _v;
	_v = _tmp9_ | (_tmp10_ >> 16);
	_tmp11_ = _v;
	result = _tmp11_ + 1;
	return result;
}


GLfloat* soy_textures_texture_get_animate (soytexturesTexture* self, int* result_length1) {
	GLfloat* result;
	GLfloat* _tmp0_;
	gint _tmp0__length1;
	GLfloat* _tmp1_;
	gint _tmp1__length1;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_animate;
	_tmp0__length1 = self->priv->_animate_length1;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}


gfloat soy_textures_texture_get_aspect (soytexturesTexture* self) {
	gfloat result;
	gfloat _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->priv->_aspect;
	result = _tmp0_;
	return result;
}


gint soy_textures_texture_get_channels (soytexturesTexture* self) {
	gint result;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_chans;
	result = _tmp0_;
	return result;
}


void soy_textures_texture_set_channels (soytexturesTexture* self, gint value) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	gboolean _tmp3_;
	gint _tmp4_;
	GLsizei _tmp5_;
	GLsizei _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp1_ = value;
	if (_tmp1_ < 1) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp2_;
		_tmp2_ = value;
		_tmp0_ = _tmp2_ > 4;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		return;
	}
	_tmp4_ = value;
	_tmp5_ = self->priv->_width;
	_tmp6_ = self->priv->_height;
	soy_textures_texture_resize (self, _tmp4_, (gint) _tmp5_, (gint) _tmp6_);
	g_object_notify ((GObject *) self, "channels");
}


static void __soy_textures_texture_size_set_soy_atoms_size_on_set (soyatomsSize* _sender, soyatomsSize* size, gpointer self) {
	_soy_textures_texture_size_set (self, size);
}


static void __soy_textures_texture_size_weak_gweak_notify (gpointer self, GObject* object) {
	_soy_textures_texture_size_weak (self, object);
}


soyatomsSize* soy_textures_texture_get_size (soytexturesTexture* self) {
	soyatomsSize* result;
	soyatomsSize* _tmp0_;
	soyatomsSize* _tmp1_;
	soyatomsSize* value;
	soyatomsSize* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_size_obj;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	value = _tmp1_;
	_tmp2_ = value;
	if (_tmp2_ == NULL) {
		GLsizei _tmp3_;
		GLsizei _tmp4_;
		soyatomsSize* _tmp5_;
		soyatomsSize* _tmp6_;
		soyatomsSize* _tmp7_;
		soyatomsSize* _tmp8_;
		_tmp3_ = self->priv->_width;
		_tmp4_ = self->priv->_height;
		_tmp5_ = soy_atoms_size_new ((gfloat) _tmp3_, (gfloat) _tmp4_, 0.0f);
		_g_object_unref0 (value);
		value = _tmp5_;
		_tmp6_ = value;
		g_signal_connect_object (_tmp6_, "on-set", (GCallback) __soy_textures_texture_size_set_soy_atoms_size_on_set, self, 0);
		_tmp7_ = value;
		g_object_weak_ref ((GObject*) _tmp7_, __soy_textures_texture_size_weak_gweak_notify, self);
		_tmp8_ = value;
		self->priv->_size_obj = _tmp8_;
	}
	result = value;
	return result;
}


void soy_textures_texture_set_size (soytexturesTexture* self, soyatomsSize* value) {
	soyatomsSize* _tmp0_;
	soyatomsSize* _tmp1_;
	soyatomsSize* _tmp5_;
	soyatomsSize* _tmp6_;
	soyatomsSize* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_soy_textures_texture_size_set (self, _tmp0_);
	_tmp1_ = self->priv->_size_obj;
	if (_tmp1_ != NULL) {
		soyatomsSize* _tmp2_;
		guint _tmp3_ = 0U;
		soyatomsSize* _tmp4_;
		_tmp2_ = self->priv->_size_obj;
		g_signal_parse_name ("on-set", SOY_ATOMS_TYPE_SIZE, &_tmp3_, NULL, FALSE);
		g_signal_handlers_disconnect_matched (_tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) __soy_textures_texture_size_set_soy_atoms_size_on_set, self);
		_tmp4_ = self->priv->_size_obj;
		g_object_weak_unref ((GObject*) _tmp4_, __soy_textures_texture_size_weak_gweak_notify, self);
	}
	_tmp5_ = value;
	self->priv->_size_obj = _tmp5_;
	_tmp6_ = value;
	g_signal_connect_object (_tmp6_, "on-set", (GCallback) __soy_textures_texture_size_set_soy_atoms_size_on_set, self, 0);
	_tmp7_ = value;
	g_object_weak_ref ((GObject*) _tmp7_, __soy_textures_texture_size_weak_gweak_notify, self);
	g_object_notify ((GObject *) self, "size");
}


gboolean soy_textures_texture_get_smooth (soytexturesTexture* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_smooth;
	result = _tmp0_;
	return result;
}


void soy_textures_texture_set_smooth (soytexturesTexture* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_smooth = _tmp0_;
	self->updated = TRUE;
	g_object_notify ((GObject *) self, "smooth");
}


gboolean soy_textures_texture_get_wrap (soytexturesTexture* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_wrap;
	result = _tmp0_;
	return result;
}


void soy_textures_texture_set_wrap (soytexturesTexture* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_wrap = _tmp0_;
	self->updated = TRUE;
	g_object_notify ((GObject *) self, "wrap");
}


static GObject * soy_textures_texture_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	soytexturesTexture * self;
	GeeHashMap* _tmp0_;
	GLfloat* _tmp1_ = NULL;
	parent_class = G_OBJECT_CLASS (soy_textures_texture_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture);
	_tmp0_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, SOY_ATOMS_TYPE_COLOR, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->_texel_objs);
	self->priv->_texel_objs = _tmp0_;
	_tmp1_ = g_new0 (GLfloat, 3);
	self->priv->_animate = (g_free (self->priv->_animate), NULL);
	self->priv->_animate = _tmp1_;
	self->priv->_animate_length1 = 3;
	self->priv->__animate_size_ = self->priv->_animate_length1;
	_vala_clear_GMutex (&self->priv->_mutex);
	g_mutex_init (&self->priv->_mutex);
	self->priv->_scaleX = (GLfloat) 0.0f;
	self->priv->_translateX = (GLfloat) 0.0f;
	self->priv->_smooth = TRUE;
	self->priv->_wrap = TRUE;
	self->translucent = FALSE;
	return obj;
}


static void soy_textures_texture_class_init (soytexturesTextureClass * klass) {
	GLenum* _tmp0_ = NULL;
	soy_textures_texture_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (soytexturesTexturePrivate));
	SOY_TEXTURES_TEXTURE_CLASS (klass)->enable = soy_textures_texture_real_enable;
	SOY_TEXTURES_TEXTURE_CLASS (klass)->disable = soy_textures_texture_real_disable;
	G_OBJECT_CLASS (klass)->get_property = _vala_soy_textures_texture_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_soy_textures_texture_set_property;
	G_OBJECT_CLASS (klass)->constructor = soy_textures_texture_constructor;
	G_OBJECT_CLASS (klass)->finalize = soy_textures_texture_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_ASPECT, g_param_spec_float ("aspect", "aspect", "aspect", -G_MAXFLOAT, G_MAXFLOAT, 0.0F, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_CHANNELS, g_param_spec_int ("channels", "channels", "channels", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_SIZE, g_param_spec_object ("size", "size", "size", SOY_ATOMS_TYPE_SIZE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_SMOOTH, g_param_spec_boolean ("smooth", "smooth", "smooth", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SOY_TEXTURES_TEXTURE_WRAP, g_param_spec_boolean ("wrap", "wrap", "wrap", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	_tmp0_ = g_new0 (GLenum, 5);
	_tmp0_[0] = (GLenum) 0;
	_tmp0_[1] = GL_LUMINANCE;
	_tmp0_[2] = GL_LUMINANCE_ALPHA;
	_tmp0_[3] = GL_RGB;
	_tmp0_[4] = GL_RGBA;
	soy_textures_texture__formats = _tmp0_;
	soy_textures_texture__formats_length1 = 5;
}


static void soy_textures_texture_instance_init (soytexturesTexture * self) {
	self->priv = SOY_TEXTURES_TEXTURE_GET_PRIVATE (self);
}


static void soy_textures_texture_finalize (GObject* obj) {
	soytexturesTexture * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture);
	_g_object_unref0 (self->priv->_texel_objs);
	_vala_clear_GMutex (&self->priv->_mutex);
	self->priv->_animate = (g_free (self->priv->_animate), NULL);
	G_OBJECT_CLASS (soy_textures_texture_parent_class)->finalize (obj);
}


GType soy_textures_texture_get_type (void) {
	static volatile gsize soy_textures_texture_type_id__volatile = 0;
	if (g_once_init_enter (&soy_textures_texture_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (soytexturesTextureClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) soy_textures_texture_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (soytexturesTexture), 0, (GInstanceInitFunc) soy_textures_texture_instance_init, NULL };
		GType soy_textures_texture_type_id;
		soy_textures_texture_type_id = g_type_register_static (G_TYPE_OBJECT, "soytexturesTexture", &g_define_type_info, 0);
		g_once_init_leave (&soy_textures_texture_type_id__volatile, soy_textures_texture_type_id);
	}
	return soy_textures_texture_type_id__volatile;
}


static void _vala_soy_textures_texture_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	soytexturesTexture * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture);
	switch (property_id) {
		case SOY_TEXTURES_TEXTURE_ASPECT:
		g_value_set_float (value, soy_textures_texture_get_aspect (self));
		break;
		case SOY_TEXTURES_TEXTURE_CHANNELS:
		g_value_set_int (value, soy_textures_texture_get_channels (self));
		break;
		case SOY_TEXTURES_TEXTURE_SIZE:
		g_value_take_object (value, soy_textures_texture_get_size (self));
		break;
		case SOY_TEXTURES_TEXTURE_SMOOTH:
		g_value_set_boolean (value, soy_textures_texture_get_smooth (self));
		break;
		case SOY_TEXTURES_TEXTURE_WRAP:
		g_value_set_boolean (value, soy_textures_texture_get_wrap (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_soy_textures_texture_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	soytexturesTexture * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture);
	switch (property_id) {
		case SOY_TEXTURES_TEXTURE_CHANNELS:
		soy_textures_texture_set_channels (self, g_value_get_int (value));
		break;
		case SOY_TEXTURES_TEXTURE_SIZE:
		soy_textures_texture_set_size (self, g_value_get_object (value));
		break;
		case SOY_TEXTURES_TEXTURE_SMOOTH:
		soy_textures_texture_set_smooth (self, g_value_get_boolean (value));
		break;
		case SOY_TEXTURES_TEXTURE_WRAP:
		soy_textures_texture_set_wrap (self, g_value_get_boolean (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_clear_GMutex (GMutex * mutex) {
	GMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GMutex))) {
		g_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GMutex));
	}
}


static void _vala_clear_GRecMutex (GRecMutex * mutex) {
	GRecMutex zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRecMutex))) {
		g_rec_mutex_clear (mutex);
		memset (mutex, 0, sizeof (GRecMutex));
	}
}


static void _vala_clear_GRWLock (GRWLock * mutex) {
	GRWLock zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GRWLock))) {
		g_rw_lock_clear (mutex);
		memset (mutex, 0, sizeof (GRWLock));
	}
}


static void _vala_clear_GCond (GCond * mutex) {
	GCond zero_mutex = { 0 };
	if (memcmp (mutex, &zero_mutex, sizeof (GCond))) {
		g_cond_clear (mutex);
		memset (mutex, 0, sizeof (GCond));
	}
}



