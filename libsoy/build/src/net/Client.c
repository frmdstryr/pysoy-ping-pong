/* Client.c generated by valac 0.20.1, the Vala compiler
 * generated from Client.gs, do not modify */

/*
 *  libsoy - soy.net.Client
 *  Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013 Copyleft Games Group
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program; if not, see http://www.gnu.org/licenses
 *
 *  soy.net.Client - a networked pysoy client. Uses ICE-UDP (XEP-0166) to setup a direct UDP connection
 *  regardless of firewalls/NATs/routers etc.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <loudmouth/loudmouth.h>
#include <float.h>
#include <math.h>
#include <agent.h>
#include <nice/agent.h>
#include <stdio.h>
#include <soy-1/ode.h>


#define SOY_NET_TYPE_CLIENT (soy_net_client_get_type ())
#define SOY_NET_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_NET_TYPE_CLIENT, soynetClient))
#define SOY_NET_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_NET_TYPE_CLIENT, soynetClientClass))
#define SOY_NET_IS_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_NET_TYPE_CLIENT))
#define SOY_NET_IS_CLIENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_NET_TYPE_CLIENT))
#define SOY_NET_CLIENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_NET_TYPE_CLIENT, soynetClientClass))

typedef struct _soynetClient soynetClient;
typedef struct _soynetClientClass soynetClientClass;
typedef struct _soynetClientPrivate soynetClientPrivate;

#define SOY_NET_TYPE_XMPP_AGENT (soy_net_xmpp_agent_get_type ())
#define SOY_NET_XMPP_AGENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_NET_TYPE_XMPP_AGENT, soynetXMPPAgent))
#define SOY_NET_XMPP_AGENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_NET_TYPE_XMPP_AGENT, soynetXMPPAgentClass))
#define SOY_NET_IS_XMPP_AGENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_NET_TYPE_XMPP_AGENT))
#define SOY_NET_IS_XMPP_AGENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_NET_TYPE_XMPP_AGENT))
#define SOY_NET_XMPP_AGENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_NET_TYPE_XMPP_AGENT, soynetXMPPAgentClass))

typedef struct _soynetXMPPAgent soynetXMPPAgent;
typedef struct _soynetXMPPAgentClass soynetXMPPAgentClass;

#define SOY_WIDGETS_TYPE_WIDGET (soy_widgets_widget_get_type ())
#define SOY_WIDGETS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_WIDGETS_TYPE_WIDGET, soywidgetsWidget))
#define SOY_WIDGETS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_WIDGETS_TYPE_WIDGET, soywidgetsWidgetClass))
#define SOY_WIDGETS_IS_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_WIDGETS_TYPE_WIDGET))
#define SOY_WIDGETS_IS_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_WIDGETS_TYPE_WIDGET))
#define SOY_WIDGETS_WIDGET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_WIDGETS_TYPE_WIDGET, soywidgetsWidgetClass))

typedef struct _soywidgetsWidget soywidgetsWidget;
typedef struct _soywidgetsWidgetClass soywidgetsWidgetClass;

#define SOY_WIDGETS_TYPE_CONTAINER (soy_widgets_container_get_type ())
#define SOY_WIDGETS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_WIDGETS_TYPE_CONTAINER, soywidgetsContainer))
#define SOY_WIDGETS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_WIDGETS_TYPE_CONTAINER, soywidgetsContainerClass))
#define SOY_WIDGETS_IS_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_WIDGETS_TYPE_CONTAINER))
#define SOY_WIDGETS_IS_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_WIDGETS_TYPE_CONTAINER))
#define SOY_WIDGETS_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_WIDGETS_TYPE_CONTAINER, soywidgetsContainerClass))

typedef struct _soywidgetsContainer soywidgetsContainer;
typedef struct _soywidgetsContainerClass soywidgetsContainerClass;

#define SOY_WIDGETS_TYPE_WINDOW (soy_widgets_window_get_type ())
#define SOY_WIDGETS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_WIDGETS_TYPE_WINDOW, soywidgetsWindow))
#define SOY_WIDGETS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_WIDGETS_TYPE_WINDOW, soywidgetsWindowClass))
#define SOY_WIDGETS_IS_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_WIDGETS_TYPE_WINDOW))
#define SOY_WIDGETS_IS_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_WIDGETS_TYPE_WINDOW))
#define SOY_WIDGETS_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_WIDGETS_TYPE_WINDOW, soywidgetsWindowClass))

typedef struct _soywidgetsWindow soywidgetsWindow;
typedef struct _soywidgetsWindowClass soywidgetsWindowClass;

#define SOY_SCENES_TYPE_SCENE (soy_scenes_scene_get_type ())
#define SOY_SCENES_SCENE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_SCENES_TYPE_SCENE, soyscenesScene))
#define SOY_SCENES_SCENE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_SCENES_TYPE_SCENE, soyscenesSceneClass))
#define SOY_SCENES_IS_SCENE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_SCENES_TYPE_SCENE))
#define SOY_SCENES_IS_SCENE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_SCENES_TYPE_SCENE))
#define SOY_SCENES_SCENE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_SCENES_TYPE_SCENE, soyscenesSceneClass))

typedef struct _soyscenesScene soyscenesScene;
typedef struct _soyscenesSceneClass soyscenesSceneClass;

#define SOY_ATOMS_TYPE_COLOR (soy_atoms_color_get_type ())
#define SOY_ATOMS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_COLOR, soyatomsColor))
#define SOY_ATOMS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_COLOR, soyatomsColorClass))
#define SOY_ATOMS_IS_COLOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_COLOR))
#define SOY_ATOMS_IS_COLOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_COLOR))
#define SOY_ATOMS_COLOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_COLOR, soyatomsColorClass))

typedef struct _soyatomsColor soyatomsColor;
typedef struct _soyatomsColorClass soyatomsColorClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _lm_connection_unref0(var) ((var == NULL) ? NULL : (var = (lm_connection_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _soynetXMPPAgentPrivate soynetXMPPAgentPrivate;

#define SOY_NET_TYPE__NETWORKTHREAD (soy_net__networkthread_get_type ())
#define SOY_NET__NETWORKTHREAD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_NET_TYPE__NETWORKTHREAD, soynet_NetworkThread))
#define SOY_NET__NETWORKTHREAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_NET_TYPE__NETWORKTHREAD, soynet_NetworkThreadClass))
#define SOY_NET_IS__NETWORKTHREAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_NET_TYPE__NETWORKTHREAD))
#define SOY_NET_IS__NETWORKTHREAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_NET_TYPE__NETWORKTHREAD))
#define SOY_NET__NETWORKTHREAD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_NET_TYPE__NETWORKTHREAD, soynet_NetworkThreadClass))

typedef struct _soynet_NetworkThread soynet_NetworkThread;
typedef struct _soynet_NetworkThreadClass soynet_NetworkThreadClass;
typedef struct _soynet_NetworkThreadPrivate soynet_NetworkThreadPrivate;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _lm_message_handler_unref0(var) ((var == NULL) ? NULL : (var = (lm_message_handler_unref (var), NULL)))
#define _lm_message_unref0(var) ((var == NULL) ? NULL : (var = (lm_message_unref (var), NULL)))
#define _lm_message_node_unref0(var) ((var == NULL) ? NULL : (var = (lm_message_node_unref (var), NULL)))
#define _g_slist_free0(var) ((var == NULL) ? NULL : (var = (g_slist_free (var), NULL)))

#define SOY_SCENES_TYPE_ROOM (soy_scenes_room_get_type ())
#define SOY_SCENES_ROOM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_SCENES_TYPE_ROOM, soyscenesRoom))
#define SOY_SCENES_ROOM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_SCENES_TYPE_ROOM, soyscenesRoomClass))
#define SOY_SCENES_IS_ROOM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_SCENES_TYPE_ROOM))
#define SOY_SCENES_IS_ROOM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_SCENES_TYPE_ROOM))
#define SOY_SCENES_ROOM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_SCENES_TYPE_ROOM, soyscenesRoomClass))

typedef struct _soyscenesRoom soyscenesRoom;
typedef struct _soyscenesRoomClass soyscenesRoomClass;

#define SOY_BODIES_TYPE_BODY (soy_bodies_body_get_type ())
#define SOY_BODIES_BODY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_BODIES_TYPE_BODY, soybodiesBody))
#define SOY_BODIES_BODY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_BODIES_TYPE_BODY, soybodiesBodyClass))
#define SOY_BODIES_IS_BODY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_BODIES_TYPE_BODY))
#define SOY_BODIES_IS_BODY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_BODIES_TYPE_BODY))
#define SOY_BODIES_BODY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_BODIES_TYPE_BODY, soybodiesBodyClass))

typedef struct _soybodiesBody soybodiesBody;
typedef struct _soybodiesBodyClass soybodiesBodyClass;

#define SOY_ATOMS_TYPE_POSITION (soy_atoms_position_get_type ())
#define SOY_ATOMS_POSITION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_POSITION, soyatomsPosition))
#define SOY_ATOMS_POSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_POSITION, soyatomsPositionClass))
#define SOY_ATOMS_IS_POSITION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_POSITION))
#define SOY_ATOMS_IS_POSITION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_POSITION))
#define SOY_ATOMS_POSITION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_POSITION, soyatomsPositionClass))

typedef struct _soyatomsPosition soyatomsPosition;
typedef struct _soyatomsPositionClass soyatomsPositionClass;

#define SOY_TEXTURES_TYPE_TEXTURE (soy_textures_texture_get_type ())
#define SOY_TEXTURES_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTexture))
#define SOY_TEXTURES_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTextureClass))
#define SOY_TEXTURES_IS_TEXTURE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_TEXTURES_TYPE_TEXTURE))
#define SOY_TEXTURES_IS_TEXTURE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_TEXTURES_TYPE_TEXTURE))
#define SOY_TEXTURES_TEXTURE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_TEXTURES_TYPE_TEXTURE, soytexturesTextureClass))

typedef struct _soytexturesTexture soytexturesTexture;
typedef struct _soytexturesTextureClass soytexturesTextureClass;

#define SOY_BODIES_TYPE_LIGHT (soy_bodies_light_get_type ())
#define SOY_BODIES_LIGHT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_BODIES_TYPE_LIGHT, soybodiesLight))
#define SOY_BODIES_LIGHT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_BODIES_TYPE_LIGHT, soybodiesLightClass))
#define SOY_BODIES_IS_LIGHT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_BODIES_TYPE_LIGHT))
#define SOY_BODIES_IS_LIGHT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_BODIES_TYPE_LIGHT))
#define SOY_BODIES_LIGHT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_BODIES_TYPE_LIGHT, soybodiesLightClass))

typedef struct _soybodiesLight soybodiesLight;
typedef struct _soybodiesLightClass soybodiesLightClass;

#define SOY_BODIES_TYPE_CAMERA (soy_bodies_camera_get_type ())
#define SOY_BODIES_CAMERA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_BODIES_TYPE_CAMERA, soybodiesCamera))
#define SOY_BODIES_CAMERA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_BODIES_TYPE_CAMERA, soybodiesCameraClass))
#define SOY_BODIES_IS_CAMERA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_BODIES_TYPE_CAMERA))
#define SOY_BODIES_IS_CAMERA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_BODIES_TYPE_CAMERA))
#define SOY_BODIES_CAMERA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_BODIES_TYPE_CAMERA, soybodiesCameraClass))

typedef struct _soybodiesCamera soybodiesCamera;
typedef struct _soybodiesCameraClass soybodiesCameraClass;

#define SOY_WIDGETS_TYPE_PROJECTOR (soy_widgets_projector_get_type ())
#define SOY_WIDGETS_PROJECTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_WIDGETS_TYPE_PROJECTOR, soywidgetsProjector))
#define SOY_WIDGETS_PROJECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_WIDGETS_TYPE_PROJECTOR, soywidgetsProjectorClass))
#define SOY_WIDGETS_IS_PROJECTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_WIDGETS_TYPE_PROJECTOR))
#define SOY_WIDGETS_IS_PROJECTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_WIDGETS_TYPE_PROJECTOR))
#define SOY_WIDGETS_PROJECTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_WIDGETS_TYPE_PROJECTOR, soywidgetsProjectorClass))

typedef struct _soywidgetsProjector soywidgetsProjector;
typedef struct _soywidgetsProjectorClass soywidgetsProjectorClass;

#define SOY_ATOMS_TYPE_SIZE (soy_atoms_size_get_type ())
#define SOY_ATOMS_SIZE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_ATOMS_TYPE_SIZE, soyatomsSize))
#define SOY_ATOMS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_ATOMS_TYPE_SIZE, soyatomsSizeClass))
#define SOY_ATOMS_IS_SIZE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_ATOMS_TYPE_SIZE))
#define SOY_ATOMS_IS_SIZE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_ATOMS_TYPE_SIZE))
#define SOY_ATOMS_SIZE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_ATOMS_TYPE_SIZE, soyatomsSizeClass))

typedef struct _soyatomsSize soyatomsSize;
typedef struct _soyatomsSizeClass soyatomsSizeClass;

#define SOY_MATERIALS_TYPE_MATERIAL (soy_materials_material_get_type ())
#define SOY_MATERIALS_MATERIAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_MATERIALS_TYPE_MATERIAL, soymaterialsMaterial))
#define SOY_MATERIALS_MATERIAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_MATERIALS_TYPE_MATERIAL, soymaterialsMaterialClass))
#define SOY_MATERIALS_IS_MATERIAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_MATERIALS_TYPE_MATERIAL))
#define SOY_MATERIALS_IS_MATERIAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_MATERIALS_TYPE_MATERIAL))
#define SOY_MATERIALS_MATERIAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_MATERIALS_TYPE_MATERIAL, soymaterialsMaterialClass))

typedef struct _soymaterialsMaterial soymaterialsMaterial;
typedef struct _soymaterialsMaterialClass soymaterialsMaterialClass;

#define SOY_MATERIALS_TYPE_COLORED (soy_materials_colored_get_type ())
#define SOY_MATERIALS_COLORED(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_MATERIALS_TYPE_COLORED, soymaterialsColored))
#define SOY_MATERIALS_COLORED_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_MATERIALS_TYPE_COLORED, soymaterialsColoredClass))
#define SOY_MATERIALS_IS_COLORED(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_MATERIALS_TYPE_COLORED))
#define SOY_MATERIALS_IS_COLORED_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_MATERIALS_TYPE_COLORED))
#define SOY_MATERIALS_COLORED_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_MATERIALS_TYPE_COLORED, soymaterialsColoredClass))

typedef struct _soymaterialsColored soymaterialsColored;
typedef struct _soymaterialsColoredClass soymaterialsColoredClass;

#define SOY_BODIES_TYPE_BOX (soy_bodies_box_get_type ())
#define SOY_BODIES_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_BODIES_TYPE_BOX, soybodiesBox))
#define SOY_BODIES_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_BODIES_TYPE_BOX, soybodiesBoxClass))
#define SOY_BODIES_IS_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_BODIES_TYPE_BOX))
#define SOY_BODIES_IS_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_BODIES_TYPE_BOX))
#define SOY_BODIES_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_BODIES_TYPE_BOX, soybodiesBoxClass))

typedef struct _soybodiesBox soybodiesBox;
typedef struct _soybodiesBoxClass soybodiesBoxClass;

struct _soynetClient {
	GObject parent_instance;
	soynetClientPrivate * priv;
	gchar* server_jid;
	gchar* username;
	gchar* password;
	LmConnection* connection;
	soynetXMPPAgent* agent;
	soywidgetsWindow* window;
	soyscenesScene* scene;
	gchar* sid;
	guint stream_id;
	gboolean connected;
	soyatomsColor* glow;
	soyatomsColor* glow2;
	gfloat glow_amt;
	gchar** ids;
	gint ids_length1;
};

struct _soynetClientClass {
	GObjectClass parent_class;
};

struct _soynetXMPPAgent {
	GObject parent_instance;
	soynetXMPPAgentPrivate * priv;
	NiceAgent* agent;
	GSList* lcands;
	GSList* rcands;
};

struct _soynetXMPPAgentClass {
	GObjectClass parent_class;
};

struct _soynet_NetworkThread {
	GObject parent_instance;
	soynet_NetworkThreadPrivate * priv;
	GMainContext* context;
};

struct _soynet_NetworkThreadClass {
	GObjectClass parent_class;
};


static gpointer soy_net_client_parent_class = NULL;
extern soynet_NetworkThread* soy_net__thread;

GType soy_net_client_get_type (void) G_GNUC_CONST;
GType soy_net_xmpp_agent_get_type (void) G_GNUC_CONST;
GType soy_widgets_widget_get_type (void) G_GNUC_CONST;
GType soy_widgets_container_get_type (void) G_GNUC_CONST;
GType soy_widgets_window_get_type (void) G_GNUC_CONST;
GType soy_scenes_scene_get_type (void) G_GNUC_CONST;
GType soy_atoms_color_get_type (void) G_GNUC_CONST;
enum  {
	SOY_NET_CLIENT_DUMMY_PROPERTY
};
soyatomsColor* soy_atoms_color_new (guchar red, guchar green, guchar blue, guchar alpha);
soyatomsColor* soy_atoms_color_construct (GType object_type, guchar red, guchar green, guchar blue, guchar alpha);
#define SOY_NET_CLIENT_session_init_iq 0
soynetClient* soy_net_client_new (const gchar* usr, const gchar* pwd, const gchar* sjid, const gchar* server, gint port);
soynetClient* soy_net_client_construct (GType object_type, const gchar* usr, const gchar* pwd, const gchar* sjid, const gchar* server, gint port);
void soy_net_client_create_window (soynetClient* self);
void soy_net_client_login (soynetClient* self);
soynetXMPPAgent* soy_net_xmpp_agent_new (void);
soynetXMPPAgent* soy_net_xmpp_agent_construct (GType object_type);
void soy_net_client_can_done (soynetClient* self, guint stream_id);
static void _soy_net_client_can_done_nice_agent_candidate_gathering_done (NiceAgent* _sender, guint stream_id, gpointer self);
GType soy_net__networkthread_get_type (void) G_GNUC_CONST;
LmHandlerResult soy_net_client_message_handler (soynetClient* self, LmMessageHandler* handler, LmConnection* connection, LmMessage* m);
static LmHandlerResult _soy_net_client_message_handler_lm_handle_message_function (LmMessageHandler* handler, LmConnection* connection, LmMessage* message, gpointer self);
LmHandlerResult soy_net_client_iq_handler (soynetClient* self, LmMessageHandler* handler, LmConnection* connection, LmMessage* m);
static LmHandlerResult _soy_net_client_iq_handler_lm_handle_message_function (LmMessageHandler* handler, LmConnection* connection, LmMessage* message, gpointer self);
void soy_net_client_connection_handler (soynetClient* self, LmConnection* connection, gboolean success);
static void _soy_net_client_connection_handler_lm_result_function (LmConnection* connection, gboolean success, gpointer self);
void soy_net_client_auth_handler (soynetClient* self, LmConnection* connection, gboolean success);
static void _soy_net_client_auth_handler_lm_result_function (LmConnection* connection, gboolean success, gpointer self);
void soy_net_client_recv (soynetClient* self, NiceAgent* agent, guint stream_id, guint component_id, guint len, const gchar* buf);
static void _soy_net_client_recv_nice_agent_nice_agent_recv_func (NiceAgent* agent, guint stream_id, guint component_id, guint len, const gchar* buf, gpointer self);
GSList* soy_net_xmpp_agent_get_remote_candidates (soynetXMPPAgent* self, LmMessageNode* transport, guint stream_id);
void soy_net_client_new_ice_xmpp_stanza (soynetClient* self, guint stream_id);
void soy_net_xmpp_agent_add_local_candidates (soynetXMPPAgent* self, LmMessageNode* transport, GSList* lcands);
void soy_net_client_send_message (soynetClient* self, const gchar* to, const gchar* body);
soywidgetsWindow* soy_widgets_window_new (void);
soywidgetsWindow* soy_widgets_window_construct (GType object_type);
soyscenesRoom* soy_scenes_room_new (gfloat size);
soyscenesRoom* soy_scenes_room_construct (GType object_type, gfloat size);
GType soy_scenes_room_get_type (void) G_GNUC_CONST;
GType soy_bodies_body_get_type (void) G_GNUC_CONST;
void soy_scenes_scene_set (soyscenesScene* self, const gchar* key, soybodiesBody* value);
soyatomsPosition* soy_atoms_position_new (gfloat x, gfloat y, gfloat z);
soyatomsPosition* soy_atoms_position_construct (GType object_type, gfloat x, gfloat y, gfloat z);
GType soy_atoms_position_get_type (void) G_GNUC_CONST;
soytexturesTexture* soy_textures_texture_new (void);
soytexturesTexture* soy_textures_texture_construct (GType object_type);
GType soy_textures_texture_get_type (void) G_GNUC_CONST;
soybodiesLight* soy_bodies_light_new (soyatomsPosition* position, gfloat size, soytexturesTexture* texture);
soybodiesLight* soy_bodies_light_construct (GType object_type, soyatomsPosition* position, gfloat size, soytexturesTexture* texture);
GType soy_bodies_light_get_type (void) G_GNUC_CONST;
soybodiesCamera* soy_bodies_camera_new (soyatomsPosition* position, gfloat radius);
soybodiesCamera* soy_bodies_camera_construct (GType object_type, soyatomsPosition* position, gfloat radius);
GType soy_bodies_camera_get_type (void) G_GNUC_CONST;
void soy_widgets_container_add_child (soywidgetsContainer* self, soywidgetsWidget* child);
soybodiesBody* soy_scenes_scene_get (soyscenesScene* self, const gchar* key);
soywidgetsProjector* soy_widgets_projector_new (soybodiesCamera* camera);
soywidgetsProjector* soy_widgets_projector_construct (GType object_type, soybodiesCamera* camera);
GType soy_widgets_projector_get_type (void) G_GNUC_CONST;
void soy_net_client_cube (soynetClient* self, gint pos);
soyatomsSize* soy_atoms_size_new (gfloat width, gfloat height, gfloat depth);
soyatomsSize* soy_atoms_size_construct (GType object_type, gfloat width, gfloat height, gfloat depth);
GType soy_atoms_size_get_type (void) G_GNUC_CONST;
soymaterialsColored* soy_materials_colored_new (const gchar* name);
soymaterialsColored* soy_materials_colored_construct (GType object_type, const gchar* name);
GType soy_materials_material_get_type (void) G_GNUC_CONST;
GType soy_materials_colored_get_type (void) G_GNUC_CONST;
soybodiesBox* soy_bodies_box_new (soyatomsPosition* position, soyatomsSize* size, soymaterialsMaterial* material);
soybodiesBox* soy_bodies_box_construct (GType object_type, soyatomsPosition* position, soyatomsSize* size, soymaterialsMaterial* material);
GType soy_bodies_box_get_type (void) G_GNUC_CONST;
void soy_bodies_body_addForce (soybodiesBody* self, dReal fx, dReal fy, dReal fz);
void soy_bodies_body_addTorque (soybodiesBody* self, dReal fx, dReal fy, dReal fz);
void soy_net_client_process_glow (soynetClient* self);
soyatomsColor* soy_widgets_window_get_background (soywidgetsWindow* self);
guchar soy_net_client_lerp (soynetClient* self, guchar in, guchar in2, gfloat amt);
guchar soy_atoms_color_get_red (soyatomsColor* self);
void soy_atoms_color_set_red (soyatomsColor* self, guchar value);
guchar soy_atoms_color_get_green (soyatomsColor* self);
void soy_atoms_color_set_green (soyatomsColor* self, guchar value);
guchar soy_atoms_color_get_blue (soyatomsColor* self);
void soy_atoms_color_set_blue (soyatomsColor* self, guchar value);
soynet_NetworkThread* soy_net__networkthread_new (void);
soynet_NetworkThread* soy_net__networkthread_construct (GType object_type);
static void soy_net_client_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


soynetClient* soy_net_client_construct (GType object_type, const gchar* usr, const gchar* pwd, const gchar* sjid, const gchar* server, gint port) {
	soynetClient * self = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	gchar** _tmp6_ = NULL;
	g_return_val_if_fail (usr != NULL, NULL);
	g_return_val_if_fail (pwd != NULL, NULL);
	g_return_val_if_fail (sjid != NULL, NULL);
	g_return_val_if_fail (server != NULL, NULL);
	self = (soynetClient*) g_object_new (object_type, NULL);
	_tmp0_ = sjid;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->server_jid);
	self->server_jid = _tmp1_;
	_tmp2_ = usr;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->username);
	self->username = _tmp3_;
	_tmp4_ = pwd;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->password);
	self->password = _tmp5_;
	_tmp6_ = g_new0 (gchar*, 1 + 1);
	self->ids = (_vala_array_free (self->ids, self->ids_length1, (GDestroyNotify) g_free), NULL);
	self->ids = _tmp6_;
	self->ids_length1 = 1;
	soy_net_client_create_window (self);
	return self;
}


soynetClient* soy_net_client_new (const gchar* usr, const gchar* pwd, const gchar* sjid, const gchar* server, gint port) {
	return soy_net_client_construct (SOY_NET_TYPE_CLIENT, usr, pwd, sjid, server, port);
}


static void _soy_net_client_can_done_nice_agent_candidate_gathering_done (NiceAgent* _sender, guint stream_id, gpointer self) {
	soy_net_client_can_done (self, stream_id);
}


static LmHandlerResult _soy_net_client_message_handler_lm_handle_message_function (LmMessageHandler* handler, LmConnection* connection, LmMessage* message, gpointer self) {
	LmHandlerResult result;
	result = soy_net_client_message_handler (self, handler, connection, message);
	return result;
}


static LmHandlerResult _soy_net_client_iq_handler_lm_handle_message_function (LmMessageHandler* handler, LmConnection* connection, LmMessage* message, gpointer self) {
	LmHandlerResult result;
	result = soy_net_client_iq_handler (self, handler, connection, message);
	return result;
}


static void _soy_net_client_connection_handler_lm_result_function (LmConnection* connection, gboolean success, gpointer self) {
	soy_net_client_connection_handler (self, connection, success);
}


void soy_net_client_login (soynetClient* self) {
	soynetXMPPAgent* _tmp0_;
	soynetXMPPAgent* _tmp1_;
	NiceAgent* _tmp2_;
	soynet_NetworkThread* _tmp3_;
	GMainContext* _tmp4_;
	LmConnection* _tmp5_;
	LmConnection* _tmp6_;
	LmConnection* _tmp7_;
	const gchar* _tmp8_;
	LmMessageHandler* _tmp9_;
	LmMessageHandler* mh;
	LmConnection* _tmp10_;
	LmMessageHandler* _tmp11_;
	LmMessageHandler* iqh;
	LmConnection* _tmp12_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = soy_net_xmpp_agent_new ();
	_g_object_unref0 (self->agent);
	self->agent = _tmp0_;
	_tmp1_ = self->agent;
	_tmp2_ = _tmp1_->agent;
	g_signal_connect_object (_tmp2_, "candidate-gathering-done", (GCallback) _soy_net_client_can_done_nice_agent_candidate_gathering_done, self, 0);
	_tmp3_ = soy_net__thread;
	_tmp4_ = _tmp3_->context;
	_tmp5_ = lm_connection_new_with_context ("jabber.de", _tmp4_);
	_lm_connection_unref0 (self->connection);
	self->connection = _tmp5_;
	_tmp6_ = self->connection;
	lm_connection_set_port (_tmp6_, (guint) 5222);
	_tmp7_ = self->connection;
	_tmp8_ = self->username;
	lm_connection_set_jid (_tmp7_, _tmp8_);
	_tmp9_ = lm_message_handler_new (_soy_net_client_message_handler_lm_handle_message_function, self, NULL);
	mh = _tmp9_;
	_tmp10_ = self->connection;
	lm_connection_register_message_handler (_tmp10_, mh, LM_MESSAGE_TYPE_MESSAGE, LM_HANDLER_PRIORITY_NORMAL);
	_tmp11_ = lm_message_handler_new (_soy_net_client_iq_handler_lm_handle_message_function, self, NULL);
	iqh = _tmp11_;
	_tmp12_ = self->connection;
	lm_connection_register_message_handler (_tmp12_, iqh, LM_MESSAGE_TYPE_IQ, LM_HANDLER_PRIORITY_NORMAL);
	{
		LmConnection* _tmp13_;
		_tmp13_ = self->connection;
		lm_connection_open (_tmp13_, _soy_net_client_connection_handler_lm_result_function, self, NULL, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* err = NULL;
		GError* _tmp14_;
		const gchar* _tmp15_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp14_ = err;
		_tmp15_ = _tmp14_->message;
		g_print ("[-] Unable to open connection - %s\n", _tmp15_);
		_g_error_free0 (err);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		_lm_message_handler_unref0 (iqh);
		_lm_message_handler_unref0 (mh);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_lm_message_handler_unref0 (iqh);
	_lm_message_handler_unref0 (mh);
}


static void _soy_net_client_auth_handler_lm_result_function (LmConnection* connection, gboolean success, gpointer self) {
	soy_net_client_auth_handler (self, connection, success);
}


void soy_net_client_connection_handler (soynetClient* self, LmConnection* connection, gboolean success) {
	gboolean _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	_tmp0_ = success;
	if (_tmp0_) {
		g_print ("[+] Connection Success\n");
		{
			LmConnection* _tmp1_;
			const gchar* _tmp2_;
			const gchar* _tmp3_;
			_tmp1_ = connection;
			_tmp2_ = self->username;
			_tmp3_ = self->password;
			lm_connection_authenticate (_tmp1_, _tmp2_, _tmp3_, "soyclient", _soy_net_client_auth_handler_lm_result_function, self, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch1_g_error;
			}
		}
		goto __finally1;
		__catch1_g_error:
		{
			GError* err = NULL;
			GError* _tmp4_;
			const gchar* _tmp5_;
			err = _inner_error_;
			_inner_error_ = NULL;
			_tmp4_ = err;
			_tmp5_ = _tmp4_->message;
			g_print ("[-] Authentication error - %s\n", _tmp5_);
			_g_error_free0 (err);
		}
		__finally1:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	} else {
		g_print ("[-] Connection Failure\n");
	}
}


static void _soy_net_client_recv_nice_agent_nice_agent_recv_func (NiceAgent* agent, guint stream_id, guint component_id, guint len, const gchar* buf, gpointer self) {
	soy_net_client_recv (self, agent, stream_id, component_id, len, buf);
}


void soy_net_client_auth_handler (soynetClient* self, LmConnection* connection, gboolean success) {
	gboolean _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (connection != NULL);
	_tmp0_ = success;
	if (_tmp0_) {
		LmMessage* _tmp1_;
		LmMessage* m;
		soynetXMPPAgent* _tmp2_;
		NiceAgent* _tmp3_;
		guint _tmp4_ = 0U;
		soynetXMPPAgent* _tmp5_;
		NiceAgent* _tmp6_;
		guint _tmp7_;
		soynet_NetworkThread* _tmp8_;
		GMainContext* _tmp9_;
		soynetXMPPAgent* _tmp10_;
		NiceAgent* _tmp11_;
		guint _tmp12_;
		g_print ("[+] Auth Success\n");
		self->connected = TRUE;
		_tmp1_ = lm_message_new_with_sub_type (NULL, LM_MESSAGE_TYPE_PRESENCE, LM_MESSAGE_SUB_TYPE_AVAILABLE);
		m = _tmp1_;
		g_print ("[+] Gathering Candidates\n");
		_tmp2_ = self->agent;
		_tmp3_ = _tmp2_->agent;
		_tmp4_ = nice_agent_add_stream (_tmp3_, (guint) 1);
		self->stream_id = _tmp4_;
		_tmp5_ = self->agent;
		_tmp6_ = _tmp5_->agent;
		_tmp7_ = self->stream_id;
		_tmp8_ = soy_net__thread;
		_tmp9_ = _tmp8_->context;
		nice_agent_attach_recv (_tmp6_, _tmp7_, (guint) 1, _tmp9_, _soy_net_client_recv_nice_agent_nice_agent_recv_func, self);
		_tmp10_ = self->agent;
		_tmp11_ = _tmp10_->agent;
		_tmp12_ = self->stream_id;
		nice_agent_gather_candidates (_tmp11_, _tmp12_);
		{
			LmConnection* _tmp13_;
			LmMessage* _tmp14_;
			_tmp13_ = connection;
			_tmp14_ = m;
			lm_connection_send (_tmp13_, _tmp14_, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch2_g_error;
			}
		}
		goto __finally2;
		__catch2_g_error:
		{
			GError* err = NULL;
			GError* _tmp15_;
			const gchar* _tmp16_;
			err = _inner_error_;
			_inner_error_ = NULL;
			_tmp15_ = err;
			_tmp16_ = _tmp15_->message;
			g_print ("[-] Sending failed, unable to set availability - %s\n", _tmp16_);
			_g_error_free0 (err);
		}
		__finally2:
		if (_inner_error_ != NULL) {
			_lm_message_unref0 (m);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_lm_message_unref0 (m);
	} else {
		g_print ("[-] Auth failed\n");
	}
}


static gpointer _lm_message_node_ref0 (gpointer self) {
	return self ? lm_message_node_ref (self) : NULL;
}


LmHandlerResult soy_net_client_message_handler (soynetClient* self, LmMessageHandler* handler, LmConnection* connection, LmMessage* m) {
	LmHandlerResult result = 0;
	LmMessage* _tmp0_;
	LmMessageNode* _tmp1_ = NULL;
	LmMessageNode* _tmp2_ = NULL;
	LmMessageNode* _tmp3_;
	LmMessageNode* body;
	LmMessageNode* _tmp4_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (handler != NULL, 0);
	g_return_val_if_fail (connection != NULL, 0);
	g_return_val_if_fail (m != NULL, 0);
	_tmp0_ = m;
	_tmp1_ = lm_message_get_node (_tmp0_);
	_tmp2_ = lm_message_node_get_child (_tmp1_, "body");
	_tmp3_ = _lm_message_node_ref0 (_tmp2_);
	body = _tmp3_;
	_tmp4_ = body;
	if (_tmp4_ != NULL) {
		LmMessageNode* _tmp5_;
		const gchar* _tmp6_;
		LmMessageNode* _tmp7_;
		const gchar* _tmp8_;
		_tmp5_ = body;
		_tmp6_ = _tmp5_->value;
		g_print ("[ ] Message %s\n", _tmp6_);
		_tmp7_ = body;
		_tmp8_ = _tmp7_->value;
		if (g_strcmp0 (_tmp8_, "start") == 0) {
			soyatomsColor* _tmp9_;
			soynetXMPPAgent* _tmp10_;
			NiceAgent* _tmp11_;
			guint _tmp12_ = 0U;
			soynetXMPPAgent* _tmp13_;
			NiceAgent* _tmp14_;
			guint _tmp15_;
			soynet_NetworkThread* _tmp16_;
			GMainContext* _tmp17_;
			soynetXMPPAgent* _tmp18_;
			NiceAgent* _tmp19_;
			guint _tmp20_;
			_tmp9_ = soy_atoms_color_new ((guchar) 255, (guchar) 255, (guchar) 0, (guchar) 255);
			_g_object_unref0 (self->glow);
			self->glow = _tmp9_;
			self->glow_amt = (gfloat) 0;
			g_print ("[+] Gathering Candidates\n");
			_tmp10_ = self->agent;
			_tmp11_ = _tmp10_->agent;
			_tmp12_ = nice_agent_add_stream (_tmp11_, (guint) 1);
			self->stream_id = _tmp12_;
			_tmp13_ = self->agent;
			_tmp14_ = _tmp13_->agent;
			_tmp15_ = self->stream_id;
			_tmp16_ = soy_net__thread;
			_tmp17_ = _tmp16_->context;
			nice_agent_attach_recv (_tmp14_, _tmp15_, (guint) 1, _tmp17_, _soy_net_client_recv_nice_agent_nice_agent_recv_func, self);
			_tmp18_ = self->agent;
			_tmp19_ = _tmp18_->agent;
			_tmp20_ = self->stream_id;
			nice_agent_gather_candidates (_tmp19_, _tmp20_);
		}
	}
	result = LM_HANDLER_RESULT_REMOVE_MESSAGE;
	_lm_message_node_unref0 (body);
	return result;
}


LmHandlerResult soy_net_client_iq_handler (soynetClient* self, LmMessageHandler* handler, LmConnection* connection, LmMessage* m) {
	LmHandlerResult result = 0;
	LmMessage* _tmp0_;
	LmMessageNode* _tmp1_ = NULL;
	LmMessageNode* _tmp2_;
	LmMessageNode* mn;
	LmMessageNode* _tmp3_;
	const gchar* _tmp4_ = NULL;
	gchar** _tmp5_;
	gint _tmp5__length1;
	const gchar* _tmp6_;
	LmMessageNode* _tmp11_;
	LmMessageNode* _tmp12_ = NULL;
	LmMessageNode* _tmp13_;
	LmMessageNode* jingle;
	gboolean _tmp14_ = FALSE;
	LmMessageNode* _tmp15_;
	gboolean _tmp18_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (handler != NULL, 0);
	g_return_val_if_fail (connection != NULL, 0);
	g_return_val_if_fail (m != NULL, 0);
	_tmp0_ = m;
	_tmp1_ = lm_message_get_node (_tmp0_);
	_tmp2_ = _lm_message_node_ref0 (_tmp1_);
	mn = _tmp2_;
	_tmp3_ = mn;
	_tmp4_ = lm_message_node_get_attribute (_tmp3_, "id");
	_tmp5_ = self->ids;
	_tmp5__length1 = self->ids_length1;
	_tmp6_ = _tmp5_[SOY_NET_CLIENT_session_init_iq];
	if (g_strcmp0 (_tmp4_, _tmp6_) == 0) {
		LmMessage* _tmp7_;
		LmMessageSubType _tmp8_ = 0;
		LmMessage* _tmp9_;
		LmMessageSubType _tmp10_ = 0;
		_tmp7_ = m;
		_tmp8_ = lm_message_get_sub_type (_tmp7_);
		if (_tmp8_ == LM_MESSAGE_SUB_TYPE_ERROR) {
			g_print ("Session init failed!\n");
		}
		_tmp9_ = m;
		_tmp10_ = lm_message_get_sub_type (_tmp9_);
		if (_tmp10_ == LM_MESSAGE_SUB_TYPE_RESULT) {
			g_print ("Session init ack\n");
		}
	}
	_tmp11_ = mn;
	_tmp12_ = lm_message_node_get_child (_tmp11_, "jingle");
	_tmp13_ = _lm_message_node_ref0 (_tmp12_);
	jingle = _tmp13_;
	_tmp15_ = jingle;
	if (_tmp15_ != NULL) {
		LmMessageNode* _tmp16_;
		const gchar* _tmp17_ = NULL;
		_tmp16_ = jingle;
		_tmp17_ = lm_message_node_get_attribute (_tmp16_, "sid");
		_tmp14_ = g_strcmp0 (_tmp17_, "somesid") == 0;
	} else {
		_tmp14_ = FALSE;
	}
	_tmp18_ = _tmp14_;
	if (_tmp18_) {
		LmMessageNode* _tmp19_;
		LmMessageNode* _tmp20_ = NULL;
		LmMessageNode* _tmp21_;
		LmMessageNode* content;
		_tmp19_ = jingle;
		_tmp20_ = lm_message_node_get_child (_tmp19_, "content");
		_tmp21_ = _lm_message_node_ref0 (_tmp20_);
		content = _tmp21_;
		{
			LmMessageNode* _tmp22_;
			_tmp22_ = content;
			if (_tmp22_ != NULL) {
				LmMessageNode* _tmp23_;
				LmMessageNode* _tmp24_ = NULL;
				LmMessageNode* _tmp25_;
				LmMessageNode* transport;
				_tmp23_ = content;
				_tmp24_ = lm_message_node_get_child (_tmp23_, "transport");
				_tmp25_ = _lm_message_node_ref0 (_tmp24_);
				transport = _tmp25_;
				{
					LmMessageNode* _tmp26_;
					const gchar* _tmp27_ = NULL;
					gchar* _tmp28_;
					gchar* ufrag;
					LmMessageNode* _tmp29_;
					const gchar* _tmp30_ = NULL;
					gchar* _tmp31_;
					gchar* tpwd;
					soynetXMPPAgent* _tmp32_;
					NiceAgent* _tmp33_;
					guint _tmp34_;
					const gchar* _tmp35_;
					const gchar* _tmp36_;
					LmMessageNode* _tmp37_;
					LmMessageNode* _tmp38_ = NULL;
					LmMessageNode* _tmp39_;
					LmMessageNode* candidate;
					LmMessageNode* _tmp40_;
					GSList* rcands = NULL;
					soynetXMPPAgent* _tmp41_;
					LmMessageNode* _tmp42_;
					guint _tmp43_;
					GSList* _tmp44_ = NULL;
					soynetXMPPAgent* _tmp45_;
					NiceAgent* _tmp46_;
					guint _tmp47_;
					GSList* _tmp48_;
					gint _tmp49_ = 0;
					gint src_res;
					gint _tmp50_;
					_tmp26_ = transport;
					_tmp27_ = lm_message_node_get_attribute (_tmp26_, "ufrag");
					_tmp28_ = g_strdup (_tmp27_);
					ufrag = _tmp28_;
					_tmp29_ = transport;
					_tmp30_ = lm_message_node_get_attribute (_tmp29_, "pwd");
					_tmp31_ = g_strdup (_tmp30_);
					tpwd = _tmp31_;
					_tmp32_ = self->agent;
					_tmp33_ = _tmp32_->agent;
					_tmp34_ = self->stream_id;
					_tmp35_ = ufrag;
					_tmp36_ = tpwd;
					nice_agent_set_remote_credentials (_tmp33_, _tmp34_, _tmp35_, _tmp36_);
					_tmp37_ = transport;
					_tmp38_ = lm_message_node_get_child (_tmp37_, "candidate");
					_tmp39_ = _lm_message_node_ref0 (_tmp38_);
					candidate = _tmp39_;
					_tmp40_ = candidate;
					if (_tmp40_ == NULL) {
						result = LM_HANDLER_RESULT_REMOVE_MESSAGE;
						_lm_message_node_unref0 (candidate);
						_g_free0 (tpwd);
						_g_free0 (ufrag);
						_lm_message_node_unref0 (transport);
						_lm_message_node_unref0 (content);
						_lm_message_node_unref0 (jingle);
						_lm_message_node_unref0 (mn);
						return result;
					}
					_tmp41_ = self->agent;
					_tmp42_ = transport;
					_tmp43_ = self->stream_id;
					_tmp44_ = soy_net_xmpp_agent_get_remote_candidates (_tmp41_, _tmp42_, _tmp43_);
					_g_slist_free0 (rcands);
					rcands = _tmp44_;
					_tmp45_ = self->agent;
					_tmp46_ = _tmp45_->agent;
					_tmp47_ = self->stream_id;
					_tmp48_ = rcands;
					_tmp49_ = nice_agent_set_remote_candidates (_tmp46_, _tmp47_, (guint) NICE_COMPONENT_TYPE_RTP, _tmp48_);
					src_res = _tmp49_;
					_tmp50_ = src_res;
					g_print ("set_remote_candidates result:  %d\n", _tmp50_);
					_g_slist_free0 (rcands);
					_lm_message_node_unref0 (candidate);
					_g_free0 (tpwd);
					_g_free0 (ufrag);
				}
				_lm_message_node_unref0 (transport);
			}
		}
		_lm_message_node_unref0 (content);
	}
	result = LM_HANDLER_RESULT_REMOVE_MESSAGE;
	_lm_message_node_unref0 (jingle);
	_lm_message_node_unref0 (mn);
	return result;
}


void soy_net_client_can_done (soynetClient* self, guint stream_id) {
	guint _tmp0_;
	g_return_if_fail (self != NULL);
	g_print ("[+] candidate gathering complete\n");
	_tmp0_ = stream_id;
	soy_net_client_new_ice_xmpp_stanza (self, _tmp0_);
}


void soy_net_client_new_ice_xmpp_stanza (soynetClient* self, guint stream_id) {
	const gchar* _tmp0_;
	LmMessage* _tmp1_;
	LmMessage* mess;
	LmMessageNode* _tmp2_ = NULL;
	LmMessageNode* _tmp3_;
	LmMessageNode* iq;
	const gchar* _tmp4_;
	gchar** _tmp5_;
	gint _tmp5__length1;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gchar* _tmp8_;
	LmMessageNode* _tmp9_ = NULL;
	LmMessageNode* _tmp10_;
	LmMessageNode* jingle;
	const gchar* _tmp11_;
	LmMessageNode* _tmp12_ = NULL;
	LmMessageNode* _tmp13_;
	LmMessageNode* content;
	LmMessageNode* _tmp14_ = NULL;
	LmMessageNode* _tmp15_;
	LmMessageNode* description;
	LmMessageNode* _tmp16_ = NULL;
	LmMessageNode* _tmp17_;
	LmMessageNode* payload;
	gchar* _tmp18_ = NULL;
	gchar* ufrag;
	gchar* _tmp19_ = NULL;
	gchar* pwd;
	soynetXMPPAgent* _tmp20_;
	NiceAgent* _tmp21_;
	guint _tmp22_;
	LmMessageNode* _tmp23_ = NULL;
	LmMessageNode* _tmp24_;
	LmMessageNode* transport;
	soynetXMPPAgent* _tmp25_;
	NiceAgent* _tmp26_;
	guint _tmp27_;
	GSList* _tmp28_ = NULL;
	GSList* _tmp29_ = NULL;
	GSList* lcands;
	soynetXMPPAgent* _tmp30_;
	gchar* _tmp31_ = NULL;
	gchar* _tmp32_;
	gchar* _tmp33_;
	gchar* _tmp34_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->server_jid;
	_tmp1_ = lm_message_new (_tmp0_, LM_MESSAGE_TYPE_IQ);
	mess = _tmp1_;
	_tmp2_ = lm_message_get_node (mess);
	_tmp3_ = _lm_message_node_ref0 (_tmp2_);
	iq = _tmp3_;
	_tmp4_ = self->username;
	lm_message_node_set_attribute (iq, "from", _tmp4_);
	lm_message_node_set_attribute (iq, "type", "set");
	_tmp5_ = self->ids;
	_tmp5__length1 = self->ids_length1;
	_tmp6_ = lm_message_node_get_attribute (iq, "id");
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (_tmp5_[SOY_NET_CLIENT_session_init_iq]);
	_tmp5_[SOY_NET_CLIENT_session_init_iq] = _tmp7_;
	_tmp8_ = _tmp5_[SOY_NET_CLIENT_session_init_iq];
	_tmp9_ = lm_message_node_add_child (iq, "jingle", NULL);
	_tmp10_ = _lm_message_node_ref0 (_tmp9_);
	jingle = _tmp10_;
	lm_message_node_set_attribute (jingle, "xmlns", "urn:xmpp:jingle:1");
	lm_message_node_set_attribute (jingle, "action", "session-initiate");
	_tmp11_ = self->username;
	lm_message_node_set_attribute (jingle, "initiator", _tmp11_);
	lm_message_node_set_attribute (jingle, "sid", "somesid");
	_tmp12_ = lm_message_node_add_child (jingle, "content", NULL);
	_tmp13_ = _lm_message_node_ref0 (_tmp12_);
	content = _tmp13_;
	lm_message_node_set_attribute (content, "creator", "initiator");
	lm_message_node_set_attribute (content, "name", "voice");
	_tmp14_ = lm_message_node_add_child (content, "description", NULL);
	_tmp15_ = _lm_message_node_ref0 (_tmp14_);
	description = _tmp15_;
	lm_message_node_set_attribute (description, "xmlns", "urn:xmpp:jingle:apps:rtp:1");
	lm_message_node_set_attribute (description, "media", "audio");
	_tmp16_ = lm_message_node_add_child (description, "payload-type", NULL);
	_tmp17_ = _lm_message_node_ref0 (_tmp16_);
	payload = _tmp17_;
	lm_message_node_set_attribute (payload, "id", "96");
	lm_message_node_set_attribute (payload, "name", "speex");
	lm_message_node_set_attribute (payload, "clockrate", "8000");
	_tmp18_ = g_new0 (gchar, 100);
	ufrag = _tmp18_;
	_tmp19_ = g_new0 (gchar, 100);
	pwd = _tmp19_;
	_tmp20_ = self->agent;
	_tmp21_ = _tmp20_->agent;
	_tmp22_ = stream_id;
	nice_agent_get_local_credentials (_tmp21_, _tmp22_, &ufrag, &pwd);
	_tmp23_ = lm_message_node_add_child (content, "transport", NULL);
	_tmp24_ = _lm_message_node_ref0 (_tmp23_);
	transport = _tmp24_;
	lm_message_node_set_attribute (transport, "xmlns", "urn:xmpp:jingle:transports:ice-udp:1");
	lm_message_node_set_attribute (transport, "ufrag", (const gchar*) ufrag);
	lm_message_node_set_attribute (transport, "pwd", (const gchar*) pwd);
	_tmp25_ = self->agent;
	_tmp26_ = _tmp25_->agent;
	_tmp27_ = stream_id;
	_tmp28_ = nice_agent_get_local_candidates (_tmp26_, _tmp27_, (guint) 1);
	_tmp29_ = g_slist_copy (_tmp28_);
	lcands = _tmp29_;
	_tmp30_ = self->agent;
	soy_net_xmpp_agent_add_local_candidates (_tmp30_, transport, lcands);
	_tmp31_ = lm_message_node_to_string (iq);
	_tmp32_ = _tmp31_;
	_tmp33_ = g_strconcat (_tmp32_, "\n", NULL);
	_tmp34_ = _tmp33_;
	g_print ("%s", _tmp34_);
	_g_free0 (_tmp34_);
	_g_free0 (_tmp32_);
	{
		LmConnection* _tmp35_;
		_tmp35_ = self->connection;
		lm_connection_send (_tmp35_, mess, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* err = NULL;
		GError* _tmp36_;
		const gchar* _tmp37_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp36_ = err;
		_tmp37_ = _tmp36_->message;
		g_print ("Unable to send message - %s\n", _tmp37_);
		_g_error_free0 (err);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_slist_free0 (lcands);
		_lm_message_node_unref0 (transport);
		_lm_message_node_unref0 (payload);
		_lm_message_node_unref0 (description);
		_lm_message_node_unref0 (content);
		_lm_message_node_unref0 (jingle);
		_lm_message_node_unref0 (iq);
		_lm_message_unref0 (mess);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_slist_free0 (lcands);
	_lm_message_node_unref0 (transport);
	_lm_message_node_unref0 (payload);
	_lm_message_node_unref0 (description);
	_lm_message_node_unref0 (content);
	_lm_message_node_unref0 (jingle);
	_lm_message_node_unref0 (iq);
	_lm_message_unref0 (mess);
}


void soy_net_client_recv (soynetClient* self, NiceAgent* agent, guint stream_id, guint component_id, guint len, const gchar* buf) {
	FILE* _tmp0_;
	FILE* _tmp1_;
	guint _tmp2_;
	guint _tmp3_;
	FILE* _tmp4_;
	const gchar* _tmp5_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (agent != NULL);
	g_return_if_fail (buf != NULL);
	_tmp0_ = stdout;
	fprintf (_tmp0_, "*****************NICE RECV!\n");
	_tmp1_ = stdout;
	_tmp2_ = stream_id;
	_tmp3_ = component_id;
	fprintf (_tmp1_, "*****************Steam %u, Component: %u\n", _tmp2_, _tmp3_);
	_tmp4_ = stdout;
	_tmp5_ = buf;
	fprintf (_tmp4_, "*****************Recv: %s\n", _tmp5_);
}


void soy_net_client_send_message (soynetClient* self, const gchar* to, const gchar* body) {
	const gchar* _tmp0_;
	LmMessage* _tmp1_;
	LmMessage* mess;
	LmMessageNode* _tmp2_ = NULL;
	LmMessageNode* _tmp3_;
	LmMessageNode* mnode;
	const gchar* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (to != NULL);
	g_return_if_fail (body != NULL);
	_tmp0_ = to;
	_tmp1_ = lm_message_new (_tmp0_, LM_MESSAGE_TYPE_MESSAGE);
	mess = _tmp1_;
	_tmp2_ = lm_message_get_node (mess);
	_tmp3_ = _lm_message_node_ref0 (_tmp2_);
	mnode = _tmp3_;
	_tmp4_ = body;
	lm_message_node_add_child (mnode, "body", _tmp4_);
	{
		LmConnection* _tmp5_;
		_tmp5_ = self->connection;
		lm_connection_send (_tmp5_, mess, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch4_g_error;
		}
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* err = NULL;
		GError* _tmp6_;
		const gchar* _tmp7_;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = err;
		_tmp7_ = _tmp6_->message;
		g_print ("Unable to send message - %s\n", _tmp7_);
		_g_error_free0 (err);
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_lm_message_node_unref0 (mnode);
		_lm_message_unref0 (mess);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_lm_message_node_unref0 (mnode);
	_lm_message_unref0 (mess);
}


void soy_net_client_create_window (soynetClient* self) {
	soywidgetsWindow* _tmp0_;
	soyscenesRoom* _tmp1_;
	soyscenesScene* _tmp2_;
	soyatomsPosition* _tmp3_;
	soyatomsPosition* _tmp4_;
	soytexturesTexture* _tmp5_;
	soytexturesTexture* _tmp6_;
	soybodiesLight* _tmp7_;
	soybodiesLight* _tmp8_;
	soyscenesScene* _tmp9_;
	soyatomsPosition* _tmp10_;
	soyatomsPosition* _tmp11_;
	soybodiesCamera* _tmp12_;
	soybodiesCamera* _tmp13_;
	soywidgetsWindow* _tmp14_;
	soyscenesScene* _tmp15_;
	soybodiesBody* _tmp16_ = NULL;
	soybodiesCamera* _tmp17_;
	soywidgetsProjector* _tmp18_;
	soywidgetsProjector* _tmp19_;
	g_return_if_fail (self != NULL);
	_tmp0_ = soy_widgets_window_new ();
	_g_object_unref0 (self->window);
	self->window = _tmp0_;
	_tmp1_ = soy_scenes_room_new (5.0f);
	_g_object_unref0 (self->scene);
	self->scene = (soyscenesScene*) _tmp1_;
	_tmp2_ = self->scene;
	_tmp3_ = soy_atoms_position_new ((gfloat) (-2), (gfloat) 3, (gfloat) (-5));
	_tmp4_ = _tmp3_;
	_tmp5_ = soy_textures_texture_new ();
	_tmp6_ = _tmp5_;
	_tmp7_ = soy_bodies_light_new (_tmp4_, 0.0f, _tmp6_);
	_tmp8_ = _tmp7_;
	soy_scenes_scene_set (_tmp2_, "light", (soybodiesBody*) _tmp8_);
	_g_object_unref0 (_tmp8_);
	_g_object_unref0 (_tmp6_);
	_g_object_unref0 (_tmp4_);
	_tmp9_ = self->scene;
	_tmp10_ = soy_atoms_position_new ((gfloat) 0, (gfloat) 0, (gfloat) 20);
	_tmp11_ = _tmp10_;
	_tmp12_ = soy_bodies_camera_new (_tmp11_, 1.0f);
	_tmp13_ = _tmp12_;
	soy_scenes_scene_set (_tmp9_, "cam", (soybodiesBody*) _tmp13_);
	_g_object_unref0 (_tmp13_);
	_g_object_unref0 (_tmp11_);
	_tmp14_ = self->window;
	_tmp15_ = self->scene;
	_tmp16_ = soy_scenes_scene_get (_tmp15_, "cam");
	_tmp17_ = G_TYPE_CHECK_INSTANCE_CAST (_tmp16_, SOY_BODIES_TYPE_CAMERA, soybodiesCamera);
	_tmp18_ = soy_widgets_projector_new (_tmp17_);
	_tmp19_ = _tmp18_;
	soy_widgets_container_add_child ((soywidgetsContainer*) _tmp14_, (soywidgetsWidget*) _tmp19_);
	_g_object_unref0 (_tmp19_);
	_g_object_unref0 (_tmp17_);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp20_;
			_tmp20_ = TRUE;
			while (TRUE) {
				gboolean _tmp21_;
				gint _tmp23_;
				_tmp21_ = _tmp20_;
				if (!_tmp21_) {
					gint _tmp22_;
					_tmp22_ = i;
					i = _tmp22_ + 1;
				}
				_tmp20_ = FALSE;
				if (!(i <= 9)) {
					break;
				}
				_tmp23_ = i;
				soy_net_client_cube (self, _tmp23_);
			}
		}
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* end;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	gboolean _tmp3_;
	glong _tmp9_;
	glong _tmp15_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		glong _tmp4_;
		glong _tmp5_;
		glong _tmp6_ = 0L;
		_tmp4_ = offset;
		_tmp5_ = len;
		_tmp6_ = string_strnlen ((gchar*) self, _tmp4_ + _tmp5_);
		string_length = _tmp6_;
	} else {
		gint _tmp7_;
		gint _tmp8_;
		_tmp7_ = strlen (self);
		_tmp8_ = _tmp7_;
		string_length = (glong) _tmp8_;
	}
	_tmp9_ = offset;
	if (_tmp9_ < ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		glong _tmp12_;
		_tmp10_ = string_length;
		_tmp11_ = offset;
		offset = _tmp10_ + _tmp11_;
		_tmp12_ = offset;
		g_return_val_if_fail (_tmp12_ >= ((glong) 0), NULL);
	} else {
		glong _tmp13_;
		glong _tmp14_;
		_tmp13_ = offset;
		_tmp14_ = string_length;
		g_return_val_if_fail (_tmp13_ <= _tmp14_, NULL);
	}
	_tmp15_ = len;
	if (_tmp15_ < ((glong) 0)) {
		glong _tmp16_;
		glong _tmp17_;
		_tmp16_ = string_length;
		_tmp17_ = offset;
		len = _tmp16_ - _tmp17_;
	}
	_tmp18_ = offset;
	_tmp19_ = len;
	_tmp20_ = string_length;
	g_return_val_if_fail ((_tmp18_ + _tmp19_) <= _tmp20_, NULL);
	_tmp21_ = offset;
	_tmp22_ = len;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp21_, (gsize) _tmp22_);
	result = _tmp23_;
	return result;
}


void soy_net_client_cube (soynetClient* self, gint pos) {
	soyscenesScene* _tmp0_;
	gint _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gint _tmp6_;
	soyatomsPosition* _tmp7_;
	soyatomsPosition* _tmp8_;
	soyatomsSize* _tmp9_;
	soyatomsSize* _tmp10_;
	soymaterialsColored* _tmp11_;
	soymaterialsColored* _tmp12_;
	soybodiesBox* _tmp13_;
	soybodiesBox* _tmp14_;
	soyscenesScene* _tmp15_;
	gint _tmp16_;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	soybodiesBody* _tmp21_ = NULL;
	soybodiesBody* _tmp22_;
	soyscenesScene* _tmp23_;
	gint _tmp24_;
	gchar* _tmp25_ = NULL;
	gchar* _tmp26_;
	gchar* _tmp27_;
	gchar* _tmp28_;
	soybodiesBody* _tmp29_ = NULL;
	soybodiesBody* _tmp30_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->scene;
	_tmp1_ = pos;
	_tmp2_ = string_substring ("0123456789", (glong) _tmp1_, (glong) 1);
	_tmp3_ = _tmp2_;
	_tmp4_ = g_strconcat ("box", _tmp3_, NULL);
	_tmp5_ = _tmp4_;
	_tmp6_ = pos;
	_tmp7_ = soy_atoms_position_new ((gfloat) _tmp6_, (gfloat) 0, (gfloat) 0);
	_tmp8_ = _tmp7_;
	_tmp9_ = soy_atoms_size_new ((gfloat) 1, (gfloat) 1, (gfloat) 1);
	_tmp10_ = _tmp9_;
	_tmp11_ = soy_materials_colored_new (NULL);
	_tmp12_ = _tmp11_;
	_tmp13_ = soy_bodies_box_new (_tmp8_, _tmp10_, (soymaterialsMaterial*) _tmp12_);
	_tmp14_ = _tmp13_;
	soy_scenes_scene_set (_tmp0_, _tmp5_, (soybodiesBody*) _tmp14_);
	_g_object_unref0 (_tmp14_);
	_g_object_unref0 (_tmp12_);
	_g_object_unref0 (_tmp10_);
	_g_object_unref0 (_tmp8_);
	_g_free0 (_tmp5_);
	_g_free0 (_tmp3_);
	_tmp15_ = self->scene;
	_tmp16_ = pos;
	_tmp17_ = string_substring ("0123456789", (glong) _tmp16_, (glong) 1);
	_tmp18_ = _tmp17_;
	_tmp19_ = g_strconcat ("box", _tmp18_, NULL);
	_tmp20_ = _tmp19_;
	_tmp21_ = soy_scenes_scene_get (_tmp15_, _tmp20_);
	_tmp22_ = _tmp21_;
	soy_bodies_body_addForce (_tmp22_, (dReal) 0.01f, (dReal) 1.01f, (dReal) 0.01f);
	_g_object_unref0 (_tmp22_);
	_g_free0 (_tmp20_);
	_g_free0 (_tmp18_);
	_tmp23_ = self->scene;
	_tmp24_ = pos;
	_tmp25_ = string_substring ("0123456789", (glong) _tmp24_, (glong) 1);
	_tmp26_ = _tmp25_;
	_tmp27_ = g_strconcat ("box", _tmp26_, NULL);
	_tmp28_ = _tmp27_;
	_tmp29_ = soy_scenes_scene_get (_tmp23_, _tmp28_);
	_tmp30_ = _tmp29_;
	soy_bodies_body_addTorque (_tmp30_, (dReal) 0.01f, (dReal) 1.1f, (dReal) 0.01f);
	_g_object_unref0 (_tmp30_);
	_g_free0 (_tmp28_);
	_g_free0 (_tmp26_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void soy_net_client_process_glow (soynetClient* self) {
	gboolean _tmp0_;
	gfloat _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->connected;
	if (_tmp0_) {
		return;
	}
	_tmp1_ = self->glow_amt;
	if (_tmp1_ < 0.2f) {
		gfloat _tmp2_;
		soywidgetsWindow* _tmp3_;
		soyatomsColor* _tmp4_;
		soyatomsColor* _tmp5_;
		soyatomsColor* _tmp6_;
		soywidgetsWindow* _tmp7_;
		soyatomsColor* _tmp8_;
		soyatomsColor* _tmp9_;
		soyatomsColor* _tmp10_;
		guchar _tmp11_;
		guchar _tmp12_;
		soyatomsColor* _tmp13_;
		guchar _tmp14_;
		guchar _tmp15_;
		gfloat _tmp16_;
		guchar _tmp17_ = '\0';
		soywidgetsWindow* _tmp18_;
		soyatomsColor* _tmp19_;
		soyatomsColor* _tmp20_;
		soyatomsColor* _tmp21_;
		soywidgetsWindow* _tmp22_;
		soyatomsColor* _tmp23_;
		soyatomsColor* _tmp24_;
		soyatomsColor* _tmp25_;
		guchar _tmp26_;
		guchar _tmp27_;
		soyatomsColor* _tmp28_;
		guchar _tmp29_;
		guchar _tmp30_;
		gfloat _tmp31_;
		guchar _tmp32_ = '\0';
		soywidgetsWindow* _tmp33_;
		soyatomsColor* _tmp34_;
		soyatomsColor* _tmp35_;
		soyatomsColor* _tmp36_;
		soywidgetsWindow* _tmp37_;
		soyatomsColor* _tmp38_;
		soyatomsColor* _tmp39_;
		soyatomsColor* _tmp40_;
		guchar _tmp41_;
		guchar _tmp42_;
		soyatomsColor* _tmp43_;
		guchar _tmp44_;
		guchar _tmp45_;
		gfloat _tmp46_;
		guchar _tmp47_ = '\0';
		_tmp2_ = self->glow_amt;
		self->glow_amt = _tmp2_ + 0.01f;
		_tmp3_ = self->window;
		_tmp4_ = soy_widgets_window_get_background (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = _tmp5_;
		_tmp7_ = self->window;
		_tmp8_ = soy_widgets_window_get_background (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = _tmp9_;
		_tmp11_ = soy_atoms_color_get_red (_tmp10_);
		_tmp12_ = _tmp11_;
		_tmp13_ = self->glow;
		_tmp14_ = soy_atoms_color_get_red (_tmp13_);
		_tmp15_ = _tmp14_;
		_tmp16_ = self->glow_amt;
		_tmp17_ = soy_net_client_lerp (self, _tmp12_, _tmp15_, _tmp16_);
		soy_atoms_color_set_red (_tmp6_, _tmp17_);
		_g_object_unref0 (_tmp10_);
		_g_object_unref0 (_tmp6_);
		_tmp18_ = self->window;
		_tmp19_ = soy_widgets_window_get_background (_tmp18_);
		_tmp20_ = _tmp19_;
		_tmp21_ = _tmp20_;
		_tmp22_ = self->window;
		_tmp23_ = soy_widgets_window_get_background (_tmp22_);
		_tmp24_ = _tmp23_;
		_tmp25_ = _tmp24_;
		_tmp26_ = soy_atoms_color_get_green (_tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = self->glow;
		_tmp29_ = soy_atoms_color_get_green (_tmp28_);
		_tmp30_ = _tmp29_;
		_tmp31_ = self->glow_amt;
		_tmp32_ = soy_net_client_lerp (self, _tmp27_, _tmp30_, _tmp31_);
		soy_atoms_color_set_green (_tmp21_, _tmp32_);
		_g_object_unref0 (_tmp25_);
		_g_object_unref0 (_tmp21_);
		_tmp33_ = self->window;
		_tmp34_ = soy_widgets_window_get_background (_tmp33_);
		_tmp35_ = _tmp34_;
		_tmp36_ = _tmp35_;
		_tmp37_ = self->window;
		_tmp38_ = soy_widgets_window_get_background (_tmp37_);
		_tmp39_ = _tmp38_;
		_tmp40_ = _tmp39_;
		_tmp41_ = soy_atoms_color_get_blue (_tmp40_);
		_tmp42_ = _tmp41_;
		_tmp43_ = self->glow;
		_tmp44_ = soy_atoms_color_get_blue (_tmp43_);
		_tmp45_ = _tmp44_;
		_tmp46_ = self->glow_amt;
		_tmp47_ = soy_net_client_lerp (self, _tmp42_, _tmp45_, _tmp46_);
		soy_atoms_color_set_blue (_tmp36_, _tmp47_);
		_g_object_unref0 (_tmp40_);
		_g_object_unref0 (_tmp36_);
	} else {
		soyatomsColor* _tmp48_;
		soyatomsColor* _tmp49_;
		soyatomsColor* temp;
		soyatomsColor* _tmp50_;
		soyatomsColor* _tmp51_;
		soyatomsColor* _tmp52_;
		soyatomsColor* _tmp53_;
		_tmp48_ = self->glow;
		_tmp49_ = _g_object_ref0 (_tmp48_);
		temp = _tmp49_;
		_tmp50_ = self->glow2;
		_tmp51_ = _g_object_ref0 (_tmp50_);
		_g_object_unref0 (self->glow);
		self->glow = _tmp51_;
		_tmp52_ = temp;
		_tmp53_ = _g_object_ref0 (_tmp52_);
		_g_object_unref0 (self->glow2);
		self->glow2 = _tmp53_;
		self->glow_amt = 0.0f;
		_g_object_unref0 (temp);
	}
}


guchar soy_net_client_lerp (soynetClient* self, guchar in, guchar in2, gfloat amt) {
	guchar result = '\0';
	guchar _tmp0_;
	gfloat _tmp1_;
	guchar _tmp2_;
	guchar _tmp3_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = in;
	_tmp1_ = amt;
	_tmp2_ = in2;
	_tmp3_ = in;
	result = (guchar) (_tmp0_ + (_tmp1_ * (_tmp2_ - _tmp3_)));
	return result;
}


static void soy_net_client_class_init (soynetClientClass * klass) {
	soynet_NetworkThread* _tmp0_;
	soy_net_client_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = soy_net_client_finalize;
	_tmp0_ = soy_net__networkthread_new ();
	_g_object_unref0 (soy_net__thread);
	soy_net__thread = _tmp0_;
}


static void soy_net_client_instance_init (soynetClient * self) {
	soyatomsColor* _tmp0_;
	soyatomsColor* _tmp1_;
	self->connected = TRUE;
	_tmp0_ = soy_atoms_color_new ((guchar) 128, (guchar) 128, (guchar) 128, (guchar) 255);
	self->glow = _tmp0_;
	_tmp1_ = soy_atoms_color_new ((guchar) 255, (guchar) 255, (guchar) 255, (guchar) 255);
	self->glow2 = _tmp1_;
	self->glow_amt = (gfloat) 1;
}


static void soy_net_client_finalize (GObject* obj) {
	soynetClient * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_NET_TYPE_CLIENT, soynetClient);
	_g_free0 (self->server_jid);
	_g_free0 (self->username);
	_g_free0 (self->password);
	_lm_connection_unref0 (self->connection);
	_g_object_unref0 (self->agent);
	_g_object_unref0 (self->window);
	_g_object_unref0 (self->scene);
	_g_free0 (self->sid);
	_g_object_unref0 (self->glow);
	_g_object_unref0 (self->glow2);
	self->ids = (_vala_array_free (self->ids, self->ids_length1, (GDestroyNotify) g_free), NULL);
	G_OBJECT_CLASS (soy_net_client_parent_class)->finalize (obj);
}


GType soy_net_client_get_type (void) {
	static volatile gsize soy_net_client_type_id__volatile = 0;
	if (g_once_init_enter (&soy_net_client_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (soynetClientClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) soy_net_client_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (soynetClient), 0, (GInstanceInitFunc) soy_net_client_instance_init, NULL };
		GType soy_net_client_type_id;
		soy_net_client_type_id = g_type_register_static (G_TYPE_OBJECT, "soynetClient", &g_define_type_info, 0);
		g_once_init_leave (&soy_net_client_type_id__volatile, soy_net_client_type_id);
	}
	return soy_net_client_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



