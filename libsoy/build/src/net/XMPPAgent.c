/* XMPPAgent.c generated by valac 0.20.1, the Vala compiler
 * generated from XMPPAgent.gs, do not modify */

/*
 *  libsoy - soy.net.XMPPAgent
 *  Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013 Copyleft Games Group
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program; if not, see http://www.gnu.org/licenses
 *
 *  soy.net.XMPPAgent - an ICE Agent that uses XMPP to share and negotiate candidates.
 */

#include <glib.h>
#include <glib-object.h>
#include <agent.h>
#include <nice/agent.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <loudmouth/loudmouth.h>


#define SOY_NET_TYPE_XMPP_AGENT (soy_net_xmpp_agent_get_type ())
#define SOY_NET_XMPP_AGENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_NET_TYPE_XMPP_AGENT, soynetXMPPAgent))
#define SOY_NET_XMPP_AGENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_NET_TYPE_XMPP_AGENT, soynetXMPPAgentClass))
#define SOY_NET_IS_XMPP_AGENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_NET_TYPE_XMPP_AGENT))
#define SOY_NET_IS_XMPP_AGENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_NET_TYPE_XMPP_AGENT))
#define SOY_NET_XMPP_AGENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_NET_TYPE_XMPP_AGENT, soynetXMPPAgentClass))

typedef struct _soynetXMPPAgent soynetXMPPAgent;
typedef struct _soynetXMPPAgentClass soynetXMPPAgentClass;
typedef struct _soynetXMPPAgentPrivate soynetXMPPAgentPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_slist_free0(var) ((var == NULL) ? NULL : (var = (g_slist_free (var), NULL)))

#define SOY_NET_TYPE__NETWORKTHREAD (soy_net__networkthread_get_type ())
#define SOY_NET__NETWORKTHREAD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SOY_NET_TYPE__NETWORKTHREAD, soynet_NetworkThread))
#define SOY_NET__NETWORKTHREAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SOY_NET_TYPE__NETWORKTHREAD, soynet_NetworkThreadClass))
#define SOY_NET_IS__NETWORKTHREAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SOY_NET_TYPE__NETWORKTHREAD))
#define SOY_NET_IS__NETWORKTHREAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SOY_NET_TYPE__NETWORKTHREAD))
#define SOY_NET__NETWORKTHREAD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SOY_NET_TYPE__NETWORKTHREAD, soynet_NetworkThreadClass))

typedef struct _soynet_NetworkThread soynet_NetworkThread;
typedef struct _soynet_NetworkThreadClass soynet_NetworkThreadClass;
typedef struct _soynet_NetworkThreadPrivate soynet_NetworkThreadPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _lm_message_node_unref0(var) ((var == NULL) ? NULL : (var = (lm_message_node_unref (var), NULL)))
#define _nice_candidate_free0(var) ((var == NULL) ? NULL : (var = (nice_candidate_free (var), NULL)))

struct _soynetXMPPAgent {
	GObject parent_instance;
	soynetXMPPAgentPrivate * priv;
	NiceAgent* agent;
	GSList* lcands;
	GSList* rcands;
};

struct _soynetXMPPAgentClass {
	GObjectClass parent_class;
};

struct _soynet_NetworkThread {
	GObject parent_instance;
	soynet_NetworkThreadPrivate * priv;
	GMainContext* context;
};

struct _soynet_NetworkThreadClass {
	GObjectClass parent_class;
};


static gpointer soy_net_xmpp_agent_parent_class = NULL;
extern GeeHashMap* soy_net_xmpp_agent_candidate_type_strs;
GeeHashMap* soy_net_xmpp_agent_candidate_type_strs = NULL;
extern GeeHashMap* soy_net_xmpp_agent_candidate_type_dict;
GeeHashMap* soy_net_xmpp_agent_candidate_type_dict = NULL;
extern soynet_NetworkThread* soy_net__thread;

GType soy_net_xmpp_agent_get_type (void) G_GNUC_CONST;
enum  {
	SOY_NET_XMPP_AGENT_DUMMY_PROPERTY
};
soynetXMPPAgent* soy_net_xmpp_agent_new (void);
soynetXMPPAgent* soy_net_xmpp_agent_construct (GType object_type);
GType soy_net__networkthread_get_type (void) G_GNUC_CONST;
void soy_net_xmpp_agent_component_state_changed (soynetXMPPAgent* self, guint p0, guint p1, NiceComponentState p2);
static void _soy_net_xmpp_agent_component_state_changed_nice_agent_component_state_changed (NiceAgent* _sender, guint p0, guint p1, NiceComponentState p2, gpointer self);
void soy_net_xmpp_agent_initial_binding_request_received (soynetXMPPAgent* self, guint p0);
static void _soy_net_xmpp_agent_initial_binding_request_received_nice_agent_initial_binding_request_received (NiceAgent* _sender, guint p0, gpointer self);
void soy_net_xmpp_agent_new_candidate (soynetXMPPAgent* self, guint p0, guint p1, const gchar* p2);
static void _soy_net_xmpp_agent_new_candidate_nice_agent_new_candidate (NiceAgent* _sender, guint p0, guint p1, const gchar* p2, gpointer self);
void soy_net_xmpp_agent_new_remote_candidate (soynetXMPPAgent* self, guint p0, guint p1, const gchar* p2);
static void _soy_net_xmpp_agent_new_remote_candidate_nice_agent_new_remote_candidate (NiceAgent* _sender, guint p0, guint p1, const gchar* p2, gpointer self);
void soy_net_xmpp_agent_new_selected_pair (soynetXMPPAgent* self, guint p0, guint p1, const gchar* p2, const gchar* p3);
static void _soy_net_xmpp_agent_new_selected_pair_nice_agent_new_selected_pair (NiceAgent* _sender, guint p0, guint p1, const gchar* p2, const gchar* p3, gpointer self);
void soy_net_xmpp_agent_reliable_transport_writable (soynetXMPPAgent* self, guint p0, guint p1);
static void _soy_net_xmpp_agent_reliable_transport_writable_nice_agent_reliable_transport_writable (NiceAgent* _sender, guint p0, guint p1, gpointer self);
const gchar* nice_component_state_to_string (NiceComponentState self);
static const char* _nice_component_state_to_string (NiceComponentState value);
void soy_net_xmpp_agent_add_local_candidates (soynetXMPPAgent* self, LmMessageNode* transport, GSList* lcands);
GSList* soy_net_xmpp_agent_get_remote_candidates (soynetXMPPAgent* self, LmMessageNode* transport, guint stream_id);
static GObject * soy_net_xmpp_agent_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
soynet_NetworkThread* soy_net__networkthread_new (void);
soynet_NetworkThread* soy_net__networkthread_construct (GType object_type);
static void soy_net_xmpp_agent_finalize (GObject* obj);


static void _soy_net_xmpp_agent_component_state_changed_nice_agent_component_state_changed (NiceAgent* _sender, guint p0, guint p1, NiceComponentState p2, gpointer self) {
	soy_net_xmpp_agent_component_state_changed (self, p0, p1, p2);
}


static void _soy_net_xmpp_agent_initial_binding_request_received_nice_agent_initial_binding_request_received (NiceAgent* _sender, guint p0, gpointer self) {
	soy_net_xmpp_agent_initial_binding_request_received (self, p0);
}


static void _soy_net_xmpp_agent_new_candidate_nice_agent_new_candidate (NiceAgent* _sender, guint p0, guint p1, const gchar* p2, gpointer self) {
	soy_net_xmpp_agent_new_candidate (self, p0, p1, p2);
}


static void _soy_net_xmpp_agent_new_remote_candidate_nice_agent_new_remote_candidate (NiceAgent* _sender, guint p0, guint p1, const gchar* p2, gpointer self) {
	soy_net_xmpp_agent_new_remote_candidate (self, p0, p1, p2);
}


static void _soy_net_xmpp_agent_new_selected_pair_nice_agent_new_selected_pair (NiceAgent* _sender, guint p0, guint p1, const gchar* p2, const gchar* p3, gpointer self) {
	soy_net_xmpp_agent_new_selected_pair (self, p0, p1, p2, p3);
}


static void _soy_net_xmpp_agent_reliable_transport_writable_nice_agent_reliable_transport_writable (NiceAgent* _sender, guint p0, guint p1, gpointer self) {
	soy_net_xmpp_agent_reliable_transport_writable (self, p0, p1);
}


soynetXMPPAgent* soy_net_xmpp_agent_construct (GType object_type) {
	soynetXMPPAgent * self = NULL;
	soynet_NetworkThread* _tmp0_;
	GMainContext* _tmp1_;
	NiceAgent* _tmp2_;
	NiceAgent* _tmp3_;
	NiceAgent* _tmp4_;
	NiceAgent* _tmp5_;
	NiceAgent* _tmp6_;
	NiceAgent* _tmp7_;
	NiceAgent* _tmp8_;
	NiceAgent* _tmp9_;
	NiceAgent* _tmp10_;
	self = (soynetXMPPAgent*) g_object_new (object_type, NULL);
	_tmp0_ = soy_net__thread;
	_tmp1_ = _tmp0_->context;
	_tmp2_ = nice_agent_new (_tmp1_, (gint) NICE_COMPATIBILITY_RFC5245);
	_g_object_unref0 (self->agent);
	self->agent = _tmp2_;
	_tmp3_ = self->agent;
	g_object_set (_tmp3_, "stun-server", "132.177.123.13", NULL);
	_tmp4_ = self->agent;
	g_object_set (_tmp4_, "stun-server-port", (guint) 3478, NULL);
	_tmp5_ = self->agent;
	g_signal_connect_object (_tmp5_, "component-state-changed", (GCallback) _soy_net_xmpp_agent_component_state_changed_nice_agent_component_state_changed, self, 0);
	_tmp6_ = self->agent;
	g_signal_connect_object (_tmp6_, "initial-binding-request-received", (GCallback) _soy_net_xmpp_agent_initial_binding_request_received_nice_agent_initial_binding_request_received, self, 0);
	_tmp7_ = self->agent;
	g_signal_connect_object (_tmp7_, "new-candidate", (GCallback) _soy_net_xmpp_agent_new_candidate_nice_agent_new_candidate, self, 0);
	_tmp8_ = self->agent;
	g_signal_connect_object (_tmp8_, "new-remote-candidate", (GCallback) _soy_net_xmpp_agent_new_remote_candidate_nice_agent_new_remote_candidate, self, 0);
	_tmp9_ = self->agent;
	g_signal_connect_object (_tmp9_, "new-selected-pair", (GCallback) _soy_net_xmpp_agent_new_selected_pair_nice_agent_new_selected_pair, self, 0);
	_tmp10_ = self->agent;
	g_signal_connect_object (_tmp10_, "reliable-transport-writable", (GCallback) _soy_net_xmpp_agent_reliable_transport_writable_nice_agent_reliable_transport_writable, self, 0);
	return self;
}


soynetXMPPAgent* soy_net_xmpp_agent_new (void) {
	return soy_net_xmpp_agent_construct (SOY_NET_TYPE_XMPP_AGENT);
}


static const char* _nice_component_state_to_string (NiceComponentState value) {
	switch (value) {
		case NICE_COMPONENT_STATE_DISCONNECTED:
		return "NICE_COMPONENT_STATE_DISCONNECTED";
		case NICE_COMPONENT_STATE_GATHERING:
		return "NICE_COMPONENT_STATE_GATHERING";
		case NICE_COMPONENT_STATE_CONNECTING:
		return "NICE_COMPONENT_STATE_CONNECTING";
		case NICE_COMPONENT_STATE_CONNECTED:
		return "NICE_COMPONENT_STATE_CONNECTED";
		case NICE_COMPONENT_STATE_READY:
		return "NICE_COMPONENT_STATE_READY";
		case NICE_COMPONENT_STATE_FAILED:
		return "NICE_COMPONENT_STATE_FAILED";
		case NICE_COMPONENT_STATE_LAST:
		return "NICE_COMPONENT_STATE_LAST";
	}
	return NULL;
}


void soy_net_xmpp_agent_component_state_changed (soynetXMPPAgent* self, guint p0, guint p1, NiceComponentState p2) {
	NiceComponentState _tmp0_;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_print ("component_state_changed\n");
	_tmp0_ = p2;
	_tmp1_ = _nice_component_state_to_string (_tmp0_);
	g_print (" state %s\n", _tmp1_);
}


void soy_net_xmpp_agent_initial_binding_request_received (soynetXMPPAgent* self, guint p0) {
	g_return_if_fail (self != NULL);
	g_print ("initial_binding_request_received\n");
}


void soy_net_xmpp_agent_new_candidate (soynetXMPPAgent* self, guint p0, guint p1, const gchar* p2) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (p2 != NULL);
	g_print ("new_candidate\n");
}


void soy_net_xmpp_agent_new_remote_candidate (soynetXMPPAgent* self, guint p0, guint p1, const gchar* p2) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (p2 != NULL);
	g_print ("new_remote_candidate\n");
}


void soy_net_xmpp_agent_new_selected_pair (soynetXMPPAgent* self, guint p0, guint p1, const gchar* p2, const gchar* p3) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (p2 != NULL);
	g_return_if_fail (p3 != NULL);
	g_print ("new_selected_pair\n");
}


void soy_net_xmpp_agent_reliable_transport_writable (soynetXMPPAgent* self, guint p0, guint p1) {
	g_return_if_fail (self != NULL);
	g_print ("reliable_transport_writable\n");
}


static gpointer _lm_message_node_ref0 (gpointer self) {
	return self ? lm_message_node_ref (self) : NULL;
}


void soy_net_xmpp_agent_add_local_candidates (soynetXMPPAgent* self, LmMessageNode* transport, GSList* lcands) {
	GSList* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (transport != NULL);
	_tmp0_ = lcands;
	{
		GSList* nice_candidate_collection = NULL;
		GSList* nice_candidate_it = NULL;
		nice_candidate_collection = _tmp0_;
		for (nice_candidate_it = nice_candidate_collection; nice_candidate_it != NULL; nice_candidate_it = nice_candidate_it->next) {
			NiceCandidate* nice_candidate = NULL;
			nice_candidate = (NiceCandidate*) nice_candidate_it->data;
			{
				gchar* _tmp1_ = NULL;
				gchar* addr;
				NiceCandidate* _tmp2_;
				const gchar* _tmp3_;
				LmMessageNode* _tmp4_;
				LmMessageNode* _tmp5_ = NULL;
				LmMessageNode* _tmp6_;
				LmMessageNode* candidate;
				LmMessageNode* _tmp7_;
				NiceCandidate* _tmp8_;
				guint _tmp9_;
				gchar* _tmp10_ = NULL;
				gchar* _tmp11_;
				LmMessageNode* _tmp12_;
				NiceCandidate* _tmp13_;
				gchar* _tmp14_;
				gint _tmp14__length1;
				LmMessageNode* _tmp15_;
				LmMessageNode* _tmp16_;
				const gchar* _tmp17_;
				LmMessageNode* _tmp18_;
				LmMessageNode* _tmp19_;
				NiceCandidate* _tmp20_;
				guint _tmp21_ = 0U;
				gchar* _tmp22_ = NULL;
				gchar* _tmp23_;
				LmMessageNode* _tmp24_;
				NiceCandidate* _tmp25_;
				guint32 _tmp26_;
				gchar* _tmp27_ = NULL;
				gchar* _tmp28_;
				LmMessageNode* _tmp29_;
				LmMessageNode* _tmp30_;
				GeeHashMap* _tmp31_;
				NiceCandidate* _tmp32_;
				NiceCandidateType _tmp33_;
				gpointer _tmp34_ = NULL;
				gchar* _tmp35_;
				_tmp1_ = g_new0 (gchar, 100);
				addr = (gchar*) _tmp1_;
				_tmp2_ = nice_candidate;
				_tmp3_ = addr;
				nice_address_to_string (&_tmp2_->addr, _tmp3_);
				_tmp4_ = transport;
				_tmp5_ = lm_message_node_add_child (_tmp4_, "candidate", NULL);
				_tmp6_ = _lm_message_node_ref0 (_tmp5_);
				candidate = _tmp6_;
				_tmp7_ = candidate;
				_tmp8_ = nice_candidate;
				_tmp9_ = _tmp8_->stream_id;
				_tmp10_ = g_strdup_printf ("%u", _tmp9_);
				_tmp11_ = _tmp10_;
				lm_message_node_set_attribute (_tmp7_, "component", _tmp11_);
				_g_free0 (_tmp11_);
				_tmp12_ = candidate;
				_tmp13_ = nice_candidate;
				_tmp14_ = _tmp13_->foundation;
				_tmp14__length1 = -1;
				lm_message_node_set_attribute (_tmp12_, "foundation", (const gchar*) _tmp14_);
				_tmp15_ = candidate;
				lm_message_node_set_attribute (_tmp15_, "id", "TBD");
				_tmp16_ = candidate;
				_tmp17_ = addr;
				lm_message_node_set_attribute (_tmp16_, "ip", _tmp17_);
				_tmp18_ = candidate;
				lm_message_node_set_attribute (_tmp18_, "network", "0");
				_tmp19_ = candidate;
				_tmp20_ = nice_candidate;
				_tmp21_ = nice_address_get_port (&_tmp20_->addr);
				_tmp22_ = g_strdup_printf ("%u", _tmp21_);
				_tmp23_ = _tmp22_;
				lm_message_node_set_attribute (_tmp19_, "port", _tmp23_);
				_g_free0 (_tmp23_);
				_tmp24_ = candidate;
				_tmp25_ = nice_candidate;
				_tmp26_ = _tmp25_->priority;
				_tmp27_ = g_strdup_printf ("%u", _tmp26_);
				_tmp28_ = _tmp27_;
				lm_message_node_set_attribute (_tmp24_, "priority", _tmp28_);
				_g_free0 (_tmp28_);
				_tmp29_ = candidate;
				lm_message_node_set_attribute (_tmp29_, "protocol", "udp");
				_tmp30_ = candidate;
				_tmp31_ = soy_net_xmpp_agent_candidate_type_strs;
				_tmp32_ = nice_candidate;
				_tmp33_ = _tmp32_->type;
				_tmp34_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp31_, (gpointer) ((gintptr) ((gint) _tmp33_)));
				_tmp35_ = (gchar*) _tmp34_;
				lm_message_node_set_attribute (_tmp30_, "type", _tmp35_);
				_g_free0 (_tmp35_);
				_lm_message_node_unref0 (candidate);
				_g_free0 (addr);
			}
		}
	}
}


static gchar* bool_to_string (gboolean self) {
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}


GSList* soy_net_xmpp_agent_get_remote_candidates (soynetXMPPAgent* self, LmMessageNode* transport, guint stream_id) {
	GSList* result = NULL;
	GSList* rcands;
	LmMessageNode* _tmp0_;
	LmMessageNode* _tmp1_ = NULL;
	LmMessageNode* _tmp2_;
	LmMessageNode* candidate;
	LmMessageNode* _tmp3_;
	GSList* _tmp49_;
	GSList* _tmp50_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (transport != NULL, NULL);
	rcands = NULL;
	_tmp0_ = transport;
	_tmp1_ = lm_message_node_get_child (_tmp0_, "candidate");
	_tmp2_ = _lm_message_node_ref0 (_tmp1_);
	candidate = _tmp2_;
	_tmp3_ = candidate;
	if (_tmp3_ == NULL) {
		result = rcands;
		_lm_message_node_unref0 (candidate);
		return result;
	}
	while (TRUE) {
		LmMessageNode* _tmp4_;
		GeeHashMap* _tmp5_;
		LmMessageNode* _tmp6_;
		const gchar* _tmp7_ = NULL;
		gpointer _tmp8_ = NULL;
		NiceCandidate* _tmp9_;
		NiceCandidate* rcand;
		LmMessageNode* _tmp10_;
		const gchar* _tmp11_ = NULL;
		gchar* _tmp12_;
		gchar* _tmp13_;
		LmMessageNode* _tmp14_;
		const gchar* _tmp15_ = NULL;
		LmMessageNode* _tmp16_;
		const gchar* _tmp17_ = NULL;
		LmMessageNode* _tmp18_;
		const gchar* _tmp19_ = NULL;
		NiceCandidate* _tmp20_;
		LmMessageNode* _tmp21_;
		const gchar* _tmp22_ = NULL;
		NiceCandidate* _tmp23_;
		LmMessageNode* _tmp24_;
		const gchar* _tmp25_ = NULL;
		gint _tmp26_ = 0;
		NiceCandidate* _tmp27_;
		NiceCandidate* _tmp28_;
		LmMessageNode* _tmp29_;
		const gchar* _tmp30_ = NULL;
		gint _tmp31_ = 0;
		NiceCandidate* _tmp32_;
		LmMessageNode* _tmp33_;
		const gchar* _tmp34_ = NULL;
		gint _tmp35_ = 0;
		NiceCandidate* _tmp36_;
		guint _tmp37_;
		NiceCandidate* _tmp38_;
		gboolean _tmp39_ = FALSE;
		gchar* _tmp40_ = NULL;
		gchar* _tmp41_;
		gchar* _tmp42_;
		gchar* _tmp43_;
		NiceCandidate* _tmp44_;
		NiceCandidate* _tmp45_ = NULL;
		LmMessageNode* _tmp46_;
		LmMessageNode* _tmp47_;
		LmMessageNode* _tmp48_;
		_tmp4_ = candidate;
		if (!(_tmp4_ != NULL)) {
			break;
		}
		_tmp5_ = soy_net_xmpp_agent_candidate_type_dict;
		_tmp6_ = candidate;
		_tmp7_ = lm_message_node_get_attribute (_tmp6_, "type");
		_tmp8_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp5_, _tmp7_);
		_tmp9_ = nice_candidate_new ((guint) ((gint) ((gintptr) _tmp8_)));
		rcand = _tmp9_;
		g_print ("Remote Candidate\n");
		_tmp10_ = candidate;
		_tmp11_ = lm_message_node_get_attribute (_tmp10_, "ip");
		_tmp12_ = g_strconcat (_tmp11_, "\n", NULL);
		_tmp13_ = _tmp12_;
		g_print ("%s", _tmp13_);
		_g_free0 (_tmp13_);
		_tmp14_ = candidate;
		_tmp15_ = lm_message_node_get_attribute (_tmp14_, "port");
		g_print ("port: %s\n", _tmp15_);
		_tmp16_ = candidate;
		_tmp17_ = lm_message_node_get_attribute (_tmp16_, "priority");
		g_print ("priority:  %s\n", _tmp17_);
		_tmp18_ = candidate;
		_tmp19_ = lm_message_node_get_attribute (_tmp18_, "component");
		g_print ("component %s\n", _tmp19_);
		_tmp20_ = rcand;
		_tmp21_ = candidate;
		_tmp22_ = lm_message_node_get_attribute (_tmp21_, "ip");
		nice_address_set_from_string (&_tmp20_->addr, _tmp22_);
		_tmp23_ = rcand;
		_tmp24_ = candidate;
		_tmp25_ = lm_message_node_get_attribute (_tmp24_, "port");
		_tmp26_ = atoi (_tmp25_);
		nice_address_set_port (&_tmp23_->addr, (guint) _tmp26_);
		_tmp27_ = rcand;
		_tmp27_->transport = NICE_CANDIDATE_TRANSPORT_UDP;
		_tmp28_ = rcand;
		_tmp29_ = candidate;
		_tmp30_ = lm_message_node_get_attribute (_tmp29_, "priority");
		_tmp31_ = atoi (_tmp30_);
		_tmp28_->priority = (guint32) _tmp31_;
		_tmp32_ = rcand;
		_tmp33_ = candidate;
		_tmp34_ = lm_message_node_get_attribute (_tmp33_, "component");
		_tmp35_ = atoi (_tmp34_);
		_tmp32_->component_id = (guint) _tmp35_;
		_tmp36_ = rcand;
		_tmp37_ = stream_id;
		_tmp36_->stream_id = _tmp37_;
		_tmp38_ = rcand;
		_tmp39_ = nice_address_is_valid (&_tmp38_->addr);
		_tmp40_ = bool_to_string (_tmp39_);
		_tmp41_ = _tmp40_;
		_tmp42_ = g_strconcat (_tmp41_, "\n", NULL);
		_tmp43_ = _tmp42_;
		g_print ("%s", _tmp43_);
		_g_free0 (_tmp43_);
		_g_free0 (_tmp41_);
		_tmp44_ = rcand;
		_tmp45_ = nice_candidate_copy (_tmp44_);
		rcands = g_slist_append (rcands, _tmp45_);
		_tmp46_ = candidate;
		_tmp47_ = _tmp46_->next;
		_tmp48_ = _lm_message_node_ref0 (_tmp47_);
		_lm_message_node_unref0 (candidate);
		candidate = _tmp48_;
		_nice_candidate_free0 (rcand);
	}
	_tmp49_ = rcands;
	_tmp50_ = g_slist_copy (_tmp49_);
	result = _tmp50_;
	_lm_message_node_unref0 (candidate);
	_g_slist_free0 (rcands);
	return result;
}


static GObject * soy_net_xmpp_agent_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	soynetXMPPAgent * self;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp1_;
	GeeHashMap* _tmp2_;
	GeeHashMap* _tmp3_;
	GeeHashMap* _tmp4_;
	GeeHashMap* _tmp5_;
	GeeHashMap* _tmp6_;
	GeeHashMap* _tmp7_;
	GeeHashMap* _tmp8_;
	GeeHashMap* _tmp9_;
	parent_class = G_OBJECT_CLASS (soy_net_xmpp_agent_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_NET_TYPE_XMPP_AGENT, soynetXMPPAgent);
	_tmp0_ = gee_hash_map_new (G_TYPE_INT, NULL, NULL, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	_g_object_unref0 (soy_net_xmpp_agent_candidate_type_strs);
	soy_net_xmpp_agent_candidate_type_strs = _tmp0_;
	_tmp1_ = soy_net_xmpp_agent_candidate_type_strs;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp1_, (gpointer) ((gintptr) ((gint) NICE_CANDIDATE_TYPE_HOST)), "host");
	_tmp2_ = soy_net_xmpp_agent_candidate_type_strs;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp2_, (gpointer) ((gintptr) ((gint) NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE)), "srflx");
	_tmp3_ = soy_net_xmpp_agent_candidate_type_strs;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp3_, (gpointer) ((gintptr) ((gint) NICE_CANDIDATE_TYPE_PEER_REFLEXIVE)), "prflx");
	_tmp4_ = soy_net_xmpp_agent_candidate_type_strs;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp4_, (gpointer) ((gintptr) ((gint) NICE_CANDIDATE_TYPE_RELAYED)), "relay");
	_tmp5_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_INT, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (soy_net_xmpp_agent_candidate_type_dict);
	soy_net_xmpp_agent_candidate_type_dict = _tmp5_;
	_tmp6_ = soy_net_xmpp_agent_candidate_type_dict;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp6_, "host", (gpointer) ((gintptr) ((gint) NICE_CANDIDATE_TYPE_HOST)));
	_tmp7_ = soy_net_xmpp_agent_candidate_type_dict;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp7_, "srflx", (gpointer) ((gintptr) ((gint) NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE)));
	_tmp8_ = soy_net_xmpp_agent_candidate_type_dict;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp8_, "prflx", (gpointer) ((gintptr) ((gint) NICE_CANDIDATE_TYPE_PEER_REFLEXIVE)));
	_tmp9_ = soy_net_xmpp_agent_candidate_type_dict;
	gee_abstract_map_set ((GeeAbstractMap*) _tmp9_, "relay", (gpointer) ((gintptr) ((gint) NICE_CANDIDATE_TYPE_RELAYED)));
	return obj;
}


static void soy_net_xmpp_agent_class_init (soynetXMPPAgentClass * klass) {
	soynet_NetworkThread* _tmp0_;
	soy_net_xmpp_agent_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->constructor = soy_net_xmpp_agent_constructor;
	G_OBJECT_CLASS (klass)->finalize = soy_net_xmpp_agent_finalize;
	_tmp0_ = soy_net__thread;
	if (_tmp0_ == NULL) {
		soynet_NetworkThread* _tmp1_;
		_tmp1_ = soy_net__networkthread_new ();
		_g_object_unref0 (soy_net__thread);
		soy_net__thread = _tmp1_;
	}
}


static void soy_net_xmpp_agent_instance_init (soynetXMPPAgent * self) {
}


static void soy_net_xmpp_agent_finalize (GObject* obj) {
	soynetXMPPAgent * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SOY_NET_TYPE_XMPP_AGENT, soynetXMPPAgent);
	_g_object_unref0 (self->agent);
	_g_slist_free0 (self->lcands);
	_g_slist_free0 (self->rcands);
	G_OBJECT_CLASS (soy_net_xmpp_agent_parent_class)->finalize (obj);
}


GType soy_net_xmpp_agent_get_type (void) {
	static volatile gsize soy_net_xmpp_agent_type_id__volatile = 0;
	if (g_once_init_enter (&soy_net_xmpp_agent_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (soynetXMPPAgentClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) soy_net_xmpp_agent_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (soynetXMPPAgent), 0, (GInstanceInitFunc) soy_net_xmpp_agent_instance_init, NULL };
		GType soy_net_xmpp_agent_type_id;
		soy_net_xmpp_agent_type_id = g_type_register_static (G_TYPE_OBJECT, "soynetXMPPAgent", &g_define_type_info, 0);
		g_once_init_leave (&soy_net_xmpp_agent_type_id__volatile, soy_net_xmpp_agent_type_id);
	}
	return soy_net_xmpp_agent_type_id__volatile;
}



